<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"icheng281.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="计算机小白一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="勇者抽刃向强者的博客">
<meta property="og:url" content="https://icheng281.github.io/index.html">
<meta property="og:site_name" content="勇者抽刃向强者的博客">
<meta property="og:description" content="计算机小白一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="icheng281">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://icheng281.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>勇者抽刃向强者的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="勇者抽刃向强者的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">勇者抽刃向强者的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">梦是现实的延续，现实是梦的终结</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="icheng281"
      src="/images/touxiang.png">
  <p class="site-author-name" itemprop="name">icheng281</p>
  <div class="site-description" itemprop="description">计算机小白一枚</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/23/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/23/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">翻转二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-23 12:23:57 / 修改时间：12:24:49" itemprop="dateCreated datePublished" datetime="2024-04-23T12:23:57+08:00">2024-04-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>395</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>思路及算法</strong></p>
<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</li>
<li>空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log⁡N)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">对称二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-23 12:23:38 / 修改时间：12:25:06" itemprop="dateCreated datePublished" datetime="2024-04-23T12:23:38+08:00">2024-04-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>805</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）递归"><a href="#（1）递归" class="headerlink" title="（1）递归"></a>（1）递归</h3><p><strong>思路及算法</strong></p>
<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/101/101_fig1.PNG" alt="fig1"></p>
<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/solution-static/101/101_fig2.PNG" alt="fig2"></p>
<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null &amp;&amp; q == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p == null || q == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(TreeNode *p, TreeNode *q) &#123;</span><br><span class="line">        if (!p &amp;&amp; !q) return true;</span><br><span class="line">        if (!p || !q) return false;</span><br><span class="line">        return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>假设树上一共 n 个节点。</p>
<ul>
<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</li>
</ul>
<h3 id="（2）迭代"><a href="#（2）迭代" class="headerlink" title="（2）迭代"></a>（2）迭代</h3><p><strong>思路及算法</strong></p>
<p>首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(TreeNode u, TreeNode v) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            if (u == null &amp;&amp; v == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((u == null || v == null) || (u.val != v.val)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(TreeNode *u, TreeNode *v) &#123;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u); q.push(v);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            u = q.front(); q.pop();</span><br><span class="line">            v = q.front(); q.pop();</span><br><span class="line">            if (!u &amp;&amp; !v) continue;</span><br><span class="line">            if ((!u || !v) || (u-&gt;val != v-&gt;val)) return false;</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;left); </span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;right); </span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/23/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/23/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/" class="post-title-link" itemprop="url">相同的树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-23 12:23:18 / 修改时间：12:24:30" itemprop="dateCreated datePublished" datetime="2024-04-23T12:23:18+08:00">2024-04-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2], q = [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2,1], q = [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p>
<p>如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</p>
<p>如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null &amp;&amp; q == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (p == null || q == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (p.val != q.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (p == nullptr &amp;&amp; q == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (p == nullptr || q == nullptr) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p>
</li>
<li><p>空间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</p>
</li>
</ul>
<h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p>
<p>也可以通过广度优先搜索判断两个二叉树是否相同。同样首先判断两个二叉树是否为空，如果两个二叉树都不为空，则从两个二叉树的根节点开始广度优先搜索。</p>
<p>使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。</p>
<ol>
<li>比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；</li>
<li>如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；</li>
<li>如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。</li>
</ol>
<p>如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null &amp;&amp; q == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (p == null || q == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue1.offer(p);</span><br><span class="line">        queue2.offer(q);</span><br><span class="line">        while (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue1.poll();</span><br><span class="line">            TreeNode node2 = queue2.poll();</span><br><span class="line">            if (node1.val != node2.val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode left1 = node1.left, right1 = node1.right, left2 = node2.left, right2 = node2.right;</span><br><span class="line">            if (left1 == null ^ left2 == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (right1 == null ^ right2 == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (left1 != null) &#123;</span><br><span class="line">                queue1.offer(left1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (right1 != null) &#123;</span><br><span class="line">                queue1.offer(right1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left2 != null) &#123;</span><br><span class="line">                queue2.offer(left2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (right2 != null) &#123;</span><br><span class="line">                queue2.offer(right2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p>
</li>
<li><p>空间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" class="post-title-link" itemprop="url">二叉树的最大深度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-22 10:39:32 / 修改时间：10:43:00" itemprop="dateCreated datePublished" datetime="2024-04-22T10:39:32+08:00">2024-04-22</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>865</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）。</p>
<ul>
<li>常见 DFS ： 先序遍历、中序遍历、后序遍历。</li>
<li>常见 BFS ： 层序遍历（即按层遍历）。</li>
</ul>
<p>求树的深度需要遍历树的所有节点，本文将介绍基于 后序遍历（DFS） 和 层序遍历（BFS） 的两种解法。</p>
<h3 id="（1）后序遍历（DFS）"><a href="#（1）后序遍历（DFS）" class="headerlink" title="（1）后序遍历（DFS）"></a>（1）后序遍历（DFS）</h3><p><strong>思路及算法</strong></p>
<p>树的后序遍历 &#x2F; 深度优先搜索往往利用 <strong>递归</strong> 或 <strong>栈</strong> 实现，这里使用递归实现。</p>
<p>关键点： 此树的深度和其左（右）子树的深度之间的关系。显然，此树的深度等于左子树的深度与右子树的深度中的最大值 +1。</p>
<p>算法解析：</p>
<ol>
<li>终止条件： 当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>递推工作： 本质上是对树做后序遍历。<ul>
<li>计算节点 <code>root</code> 的 左子树的深度 ，即调用<code> maxDepth(root.left)</code>。</li>
<li>计算节点 <code>root</code> 的 右子树的深度 ，即调用 <code>maxDepth(root.right)</code>。</li>
</ul>
</li>
<li>返回值： 返回 此树的深度 ，即<code> max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1603024336-bRXFKg-Picture2.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-xohQQM-Picture3.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-LXqphi-Picture4.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-kHinqB-Picture5.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-hltgwg-Picture6.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-tcizEe-Picture7.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-mbVGBM-Picture8.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-KGNMeX-Picture9.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-AlgMZC-Picture10.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-YjXKMf-Picture11.png" alt="img"></p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N)： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
<h3 id="（2）层序遍历（BFS）"><a href="#（2）层序遍历（BFS）" class="headerlink" title="（2）层序遍历（BFS）"></a>（2）层序遍历（BFS）</h3><p><strong>思路及算法</strong></p>
<p>树的层序遍历 &#x2F; 广度优先搜索往往利用 <strong>队列</strong> 实现。</p>
<p><strong>关键点：</strong> 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</p>
<p>算法解析：</p>
<ol>
<li>特例处理： 当 <code>root</code> 为空，直接返回 深度 0 。</li>
<li>初始化： 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li>循环遍历： 当 <code>queue </code>为空时跳出。<ul>
<li>初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点。</li>
<li>遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入<code> tmp</code>。</li>
<li>更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>。</li>
<li>统计层数： 执行 <code>res += 1</code> ，代表层数加 1。</li>
</ul>
</li>
<li>返回值： 返回 <code>res</code> 即可。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1603024336-ZojeTj-Picture12.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-fMIPed-Picture13.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-ANiQQj-Picture14.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-EXcbJg-Picture15.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-dSOwtz-Picture16.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1603024336-byqvuK-Picture17.png" alt="img"></p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        List&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            tmp = new LinkedList&lt;&gt;();</span><br><span class="line">            for(TreeNode node : queue) &#123;</span><br><span class="line">                if (node.left != null) tmp.add(node.left);</span><br><span class="line">                if (node.right != null) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue = tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        vector&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push_back(root);</span><br><span class="line">        int res = 0;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">            for(TreeNode* node : que) &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) tmp.push_back(node-&gt;left);</span><br><span class="line">                if (node-&gt;right != nullptr) tmp.push_back(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            que = tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N)： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N)： 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 N&#x2F;2 个节点。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树的中序遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-22 10:37:24 / 修改时间：10:42:42" itemprop="dateCreated datePublished" datetime="2024-04-22T10:37:24+08:00">2024-04-22</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>557</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）递归"><a href="#（1）递归" class="headerlink" title="（1）递归"></a>（1）递归</h3><p><strong>思路及算法</strong></p>
<p>递归遍历过程如下：</p>
<ol>
<li>前序遍历：打印 - 左 - 右</li>
<li>中序遍历：左 - 打印 - 右</li>
<li>后序遍历：左 - 右 - 打印</li>
</ol>
<p>题目要求的是中序遍历，那就按照 左-打印-右这种顺序遍历树就可以了，递归函数实现</p>
<ul>
<li>终止条件：当前节点为空时</li>
<li>函数内：递归的调用左节点，打印当前节点，再递归调用右节点</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		dfs(res,root);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void dfs(List&lt;Integer&gt; res, TreeNode root) &#123;</span><br><span class="line">		if(root==null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//按照 左-打印-右的方式遍历</span><br><span class="line">		dfs(res,root.left);</span><br><span class="line">		res.add(root.val);</span><br><span class="line">		dfs(res,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(h)，h 是树的高度。</li>
</ul>
<h3 id="（2）迭代"><a href="#（2）迭代" class="headerlink" title="（2）迭代"></a>（2）迭代</h3><p><strong>思路及算法</strong></p>
<p>递归实现时，是函数自己调用自己，一层层的嵌套下去，操作系统&#x2F;虚拟机自动帮我们用 <strong>栈</strong> 来保存了每个调用的函数，现在我们需要自己模拟这样的调用过程。</p>
<p>递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。<br>我们在迭代实现时，就可以用栈来模拟上面的调用过程。</p>
<p><img src="https://pic.leetcode-cn.com/47fff35dd3fd640ba60349c78b85242ae8f4b850f06a282cd7e92c91e6eff406-1.gif" alt="1.gif"></p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">		while(stack.size()&gt;0 || root!=null) &#123;</span><br><span class="line">			//不断往左子树方向走，每走一次就将当前节点保存到栈中</span><br><span class="line">			//这是模拟递归的调用</span><br><span class="line">			if(root!=null) &#123;</span><br><span class="line">				stack.add(root);</span><br><span class="line">				root = root.left;</span><br><span class="line">			//当前节点为空，说明左边走到头了，从栈中弹出节点并保存</span><br><span class="line">			//然后转向右边节点，继续上面整个过程</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				TreeNode tmp = stack.pop();</span><br><span class="line">				res.add(tmp.val);</span><br><span class="line">				root = tmp.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)，h 是树的高度</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/19/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/19/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/" class="post-title-link" itemprop="url">基本计算器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-19 10:14:48 / 修改时间：10:17:06" itemprop="dateCreated datePublished" datetime="2024-04-19T10:14:48+08:00">2024-04-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
<li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li>
<li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li>
<li>输入中不存在两个连续的操作符</li>
<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h3><p><strong>思路及算法</strong></p>
<p>我们可以使用两个栈 <code>nums</code> 和 <code>ops</code> 。</p>
<ul>
<li><code>nums</code> ： 存放所有的数字</li>
<li><code>ops</code> ：存放所有的数字以外的操作，<code>+/-</code> 也看做是一种操作</li>
</ul>
<p>然后从前往后做，对遍历到的字符做分情况讨论：</p>
<ul>
<li>空格 : 跳过</li>
<li><code>( </code>: 直接加入 <code>ops</code> 中，等待与之匹配的 )</li>
<li><code>)</code> : 使用现有的 <code>nums</code> 和 <code>ops</code> 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 <code>nums</code></li>
<li>数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 <code>nums</code></li>
<li><code>+/-</code> : 需要将操作放入 <code>ops</code> 中。在放入之前先把栈内可以算的都算掉，使用现有的 <code>nums</code> 和 <code>ops</code> 进行计算，直到没有操作或者遇到左括号，计算结果放到 <code>nums</code></li>
</ul>
<p>一些细节：</p>
<ul>
<li>由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 <code>nums</code> 添加一个 <code>0</code></li>
<li>为防止<code>()</code>内出现的首个字符为运算符，将所有的空格去掉，并将<code>(-</code>替换为 <code>(0-</code>，<code>(+</code> 替换为 <code>(0+</code>（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replace(string&amp; s)&#123;</span><br><span class="line">        int pos = s.find(&quot; &quot;);</span><br><span class="line">        while (pos != -1) &#123;</span><br><span class="line">            s.replace(pos, 1, &quot;&quot;);</span><br><span class="line">            pos = s.find(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        // 存放所有的数字</span><br><span class="line">        stack&lt;int&gt; nums;</span><br><span class="line">        // 为了防止第一个数为负数，先往 nums 加个 0</span><br><span class="line">        nums.push(0);</span><br><span class="line">        // 将所有的空格去掉</span><br><span class="line">        replace(s);</span><br><span class="line">        // 存放所有的操作，包括 +/-</span><br><span class="line">        stack&lt;char&gt; ops;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = s[i];</span><br><span class="line">            if(c == &#x27;(&#x27;)</span><br><span class="line">                ops.push(c);</span><br><span class="line">            else if(c == &#x27;)&#x27;) &#123;</span><br><span class="line">                // 计算到最近一个左括号为止</span><br><span class="line">                while(!ops.empty()) &#123;</span><br><span class="line">                    char op = ops.top();</span><br><span class="line">                    if(op != &#x27;(&#x27;)</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    else &#123;</span><br><span class="line">                        ops.pop();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(isdigit(c)) &#123;</span><br><span class="line">                    int cur_num = 0;</span><br><span class="line">                    int j = i;</span><br><span class="line">                    // 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br><span class="line">                    while(j &lt;n &amp;&amp; isdigit(s[j]))</span><br><span class="line">                        cur_num = cur_num*10 + (s[j++] - &#x27;0&#x27;);</span><br><span class="line">                    // 注意上面的计算一定要有括号，否则有可能会溢出</span><br><span class="line">                    nums.push(cur_num);</span><br><span class="line">                    i = j-1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (i &gt; 0 &amp;&amp; (s[i - 1] == &#x27;(&#x27; || s[i - 1] == &#x27;+&#x27; || s[i - 1] == &#x27;-&#x27;)) &#123;</span><br><span class="line">                        nums.push(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 有一个新操作要入栈时，先把栈内可以算的都算了</span><br><span class="line">                    while(!ops.empty() &amp;&amp; ops.top() != &#x27;(&#x27;)</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    ops.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!ops.empty())</span><br><span class="line">            calc(nums, ops);</span><br><span class="line">        return nums.top();</span><br><span class="line">    &#125;</span><br><span class="line">    void calc(stack&lt;int&gt; &amp;nums, stack&lt;char&gt; &amp;ops) &#123;</span><br><span class="line">        if(nums.size() &lt; 2 || ops.empty())</span><br><span class="line">            return;</span><br><span class="line">        int b = nums.top(); nums.pop();</span><br><span class="line">        int a = nums.top(); nums.pop();</span><br><span class="line">        char op = ops.top(); ops.pop();</span><br><span class="line">        nums.push(op == &#x27;+&#x27; ? a+b : a-b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        // 存放所有的数字</span><br><span class="line">        Deque&lt;Integer&gt; nums = new ArrayDeque&lt;&gt;();</span><br><span class="line">        // 为了防止第一个数为负数，先往 nums 加个 0</span><br><span class="line">        nums.addLast(0);</span><br><span class="line">        // 将所有的空格去掉</span><br><span class="line">        s = s.replaceAll(&quot; &quot;, &quot;&quot;);</span><br><span class="line">        // 存放所有的操作，包括 +/-</span><br><span class="line">        Deque&lt;Character&gt; ops = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        char[] cs = s.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = cs[i];</span><br><span class="line">            if (c == &#x27;(&#x27;) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; else if (c == &#x27;)&#x27;) &#123;</span><br><span class="line">                // 计算到最近一个左括号为止</span><br><span class="line">                while (!ops.isEmpty()) &#123;</span><br><span class="line">                    char op = ops.peekLast();</span><br><span class="line">                    if (op != &#x27;(&#x27;) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (isNum(c)) &#123;</span><br><span class="line">                    int u = 0;</span><br><span class="line">                    int j = i;</span><br><span class="line">                    // 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br><span class="line">                    while (j &lt; n &amp;&amp; isNum(cs[j])) u = u * 10 + (int)(cs[j++] - &#x27;0&#x27;);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (i &gt; 0 &amp;&amp; (cs[i - 1] == &#x27;(&#x27; || cs[i - 1] == &#x27;+&#x27; || cs[i - 1] == &#x27;-&#x27;)) &#123;</span><br><span class="line">                        nums.addLast(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 有一个新操作要入栈时，先把栈内可以算的都算了</span><br><span class="line">                    while (!ops.isEmpty() &amp;&amp; ops.peekLast() != &#x27;(&#x27;) calc(nums, ops);</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        return nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    void calc(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops) &#123;</span><br><span class="line">        if (nums.isEmpty() || nums.size() &lt; 2) return;</span><br><span class="line">        if (ops.isEmpty()) return;</span><br><span class="line">        int b = nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        char op = ops.pollLast();</span><br><span class="line">        nums.addLast(op == &#x27;+&#x27; ? a + b : a - b);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isNum(char c) &#123;</span><br><span class="line">        return Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/19/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/19/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/" class="post-title-link" itemprop="url">柱状图中最大的矩形</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-19 10:14:22 / 修改时间：10:16:38" itemprop="dateCreated datePublished" datetime="2024-04-19T10:14:22+08:00">2024-04-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;=105</code></li>
<li><code>0 &lt;= heights[i] &lt;= 104</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（3）单调栈"><a href="#（3）单调栈" class="headerlink" title="（3）单调栈"></a>（3）单调栈</h3><p><strong>思路及算法</strong></p>
<p>我们归纳一下枚举「高」的方法：</p>
<ul>
<li>首先我们枚举某一根柱子 i 作为高 h&#x3D;heights[i]；</li>
<li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。换句话说，我们需要找到左右两侧最近的高度小于 h 的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 h，并且就是 iii 能够扩展到的最远范围。</li>
</ul>
<p>那么我们先来看看如何求出一根柱子的左侧且最近的小于其高度的柱子。除了根据「前言」部分暴力地进行枚举之外，我们可以通过如下的一个结论来深入地进行思考：</p>
<p>对于两根柱子 j0 以及 j1，如果 j0&lt;j1并且 heights[j0]≥heights[j1]，那么对于任意的在它们之后出现的柱子 i（j1&lt;i） 一定不会是 i 左侧且最近的小于其高度的柱子。</p>
<p>换句话说，如果有两根柱子 j0 和 j1，其中 j0 在 j1 的左侧，并且 j0 的高度大于等于 j1，那么在后面的柱子 i 向左找小于其高度的柱子时，j1 会「挡住」j0，j0 就不会作为答案了。</p>
<p>这样以来，我们可以对数组从左向右进行遍历，同时维护一个「可能作为答案」的数据结构，其中按照从小到大的顺序存放了一些 j 值。根据上面的结论，如果我们存放了 j0,j1,⋯ ,js，那么一定有 height[j0]&lt;height[j1]&lt;⋯&lt;height[js]，因为如果有两个相邻的 j 值对应的高度不满足 &lt; 关系，那么后者会「挡住」前者，前者就不可能作为答案了。</p>
<p>当我们枚举到第 i 根柱子时，我们的数据结构中存放了 j0,j1,⋯ ,js，如果第 iii 根柱子左侧且最近的小于其高度的柱子为 ji，那么必然有height[j0]&lt;height[j1]&lt;⋯&lt;height[ji]&lt;height[i]≤height[ji+1]&lt;⋯&lt;height[js] 这样我们就可以使用二分查找的方法找到 i 对应的 ji，但真的需要吗？当我们枚举到 i+1 时，原来的 i 也变成了 j值，因此 i 会被放入数据结构。由于所有在数据结构中的 j 值均小于 i，那么所有高度大于等于 height[i] 的 j 都不会作为答案，需要从数据结构中移除。而我们发现，这些被移除的 j 值恰好就是ji+1,⋯ ,js。</p>
<p>这样我们在枚举到第 i 根柱子的时候，就可以先把所有高度大于等于 height[i] 的 j 值全部移除，剩下的 j值中高度最高的即为答案。在这之后，我们将 i 放入数据结构中，开始接下来的枚举。此时，我们需要使用的数据结构也就呼之欲出了，它就是栈。</p>
<ul>
<li><p>栈中存放了 j 值。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</p>
</li>
<li><p>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 height[j]≥height[i] 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 height[j]&lt;height[i]，此时 j 就是 i 左侧且最近的小于其高度的柱子。</p>
<ul>
<li>这里会有一种特殊情况。如果我们移除了栈中所有的 j 值，那就说明 i 左侧所有柱子的高度都大于 height[i]，那么我们可以认为 i 左侧且最近的小于其高度的柱子在位置 j&#x3D;−1，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li>
</ul>
</li>
<li><p>我们再将 i 放入栈顶。</p>
</li>
</ul>
<p>栈中存放的元素具有单调性，这就是经典的数据结构「单调栈」了。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n);</span><br><span class="line">        </span><br><span class="line">        stack&lt;int&gt; mono_stack;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.empty() ? -1 : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = stack&lt;int&gt;();</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.empty() ? n : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        int n = heights.length;</span><br><span class="line">        int[] left = new int[n];</span><br><span class="line">        int[] right = new int[n];</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack.clear();</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h3 id="（2）单调栈-常数优化"><a href="#（2）单调栈-常数优化" class="headerlink" title="（2）单调栈+常数优化"></a>（2）单调栈+常数优化</h3><p><strong>思路及算法</strong></p>
<p>在方法一中，我们首先从左往右对数组进行遍历，借助单调栈求出了每根柱子的左边界，随后从右往左对数组进行遍历，借助单调栈求出了每根柱子的右边界。那么我们是否可以只遍历一次就求出答案呢？</p>
<p>答案是可以的。在方法一中，我们在对位置 i 进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置 i 进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置 i 被弹出栈时，说明此时遍历到的位置 i0 的高度小于等于 height[i]，并且在 i0 与 i 之间没有其他高度小于等于 height[i] 的柱子。这是因为，如果在 i 和 i0之间还有其它位置的高度小于等于 height[i] 的，那么在遍历到那个位置的时候，i 应该已经被弹出栈了。所以位置 i0 就是位置 i 的右边界。</p>
<p>等等，我们需要的是「一根柱子的左侧且最近的小于其高度的柱子」，但这里我们求的是小于等于，那么会造成什么影响呢？答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么最右侧的那根柱子是可以求出正确的右边界的，而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。读者可以仔细思考一下这一步。</p>
<p>在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 n 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 n。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n, n);</span><br><span class="line">        </span><br><span class="line">        stack&lt;int&gt; mono_stack;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.top()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.empty() ? -1 : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        int n = heights.length;</span><br><span class="line">        int[] left = new int[n];</span><br><span class="line">        int[] right = new int[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.peek()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/18/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/18/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" class="post-title-link" itemprop="url">逆波兰表达式求值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-18 10:09:35 / 修改时间：10:10:36" itemprop="dateCreated datePublished" datetime="2024-04-18T10:09:35+08:00">2024-04-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>907</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据<strong>逆波兰表示法</strong>表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>思路及算法</strong></p>
<p>逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：</p>
<ul>
<li>如果遇到操作数，则将操作数入栈；</li>
<li>如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。</li>
</ul>
<p>整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        int n = tokens.length;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            String token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stack.pop();</span><br><span class="line">                int num1 = stack.pop();</span><br><span class="line">                switch (token) &#123;</span><br><span class="line">                    case &quot;+&quot;:</span><br><span class="line">                        stack.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;-&quot;:</span><br><span class="line">                        stack.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;*&quot;:</span><br><span class="line">                        stack.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;/&quot;:</span><br><span class="line">                        stack.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isNumber(String token) &#123;</span><br><span class="line">        return !(&quot;+&quot;.equals(token) || &quot;-&quot;.equals(token) || &quot;*&quot;.equals(token) || &quot;/&quot;.equals(token));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stk.push(atoi(token.c_str()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                int num1 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        stk.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string&amp; token) &#123;</span><br><span class="line">        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组 tokens 的长度。需要遍历数组 tokens 一次，计算逆波兰表达式的值。</li>
<li>空间复杂度：O(n)，其中 n 是数组 tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/18/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/18/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/" class="post-title-link" itemprop="url">每日温度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-18 10:08:43 / 修改时间：10:10:15" itemprop="dateCreated datePublished" datetime="2024-04-18T10:08:43+08:00">2024-04-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><strong>思路及算法</strong></p>
<p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素<code> temperatures[i]</code>，如果栈为空，则直接将<code> i</code> 进栈，如果栈不为空，则比较栈顶元素 <code>prevIndex</code> 对应的温度 <code>temperatures[prevIndex]</code> 和当前温度 <code>temperatures[i]</code>，如果 <code>temperatures[i] &gt; temperatures[prevIndex]</code>，则将 <code>prevIndex</code> 移除，并将 <code>prevIndex</code> 对应的等待天数赋为<code> i - prevIndex</code>，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 <code>i </code>进栈。</p>
<p>为什么可以在弹栈的时候更新 <code>ans[prevIndex] </code>呢？因为在这种情况下，即将进栈的 <code>i </code>对应的 <code>temperatures[i] </code>一定是 <code>temperatures[prevIndex]</code> 右边第一个比它大的元素，试想如果 <code>prevIndex</code> 和 <code>i </code>有比它大的元素，假设下标为 <code>j</code>，那么 <code>prevIndex</code> 一定会在下标<code>j</code>的那一轮被弹掉。</p>
<p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p>
<p>以下用一个具体的例子帮助读者理解单调栈。对于温度列表 [73,74,75,71,69,72,76,73]，单调栈 <code>stack</code> 的初始状态为空，答案 <code>ans</code> 的初始状态[0,0,0,0,0,0,0,0]，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。</p>
<ul>
<li><p>当 i&#x3D;0 时，单调栈为空，因此将 0 进栈。</p>
<ul>
<li>stack&#x3D;[0(73)]</li>
<li>ans&#x3D;[0,0,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;1 时，由于 74 大于 73，因此移除栈顶元素 0，赋值 ans[0]:&#x3D;1−0，将 1 进栈。</p>
<ul>
<li>stack&#x3D;[1(74)]</li>
<li>ans&#x3D;[1,0,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;2 时，由于 75 大于 74，因此移除栈顶元素 1，赋值 ans[1]:&#x3D;2−1，将 2 进栈。</p>
<ul>
<li>stack&#x3D;[2(75)]</li>
<li>ans&#x3D;[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;3 时，由于 71 小于 75，因此将 3 进栈。</p>
<ul>
<li>stack&#x3D;[2(75),3(71)]</li>
<li>ans&#x3D;[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;4 时，由于 69 小于 71，因此将 4 进栈。</p>
<ul>
<li>stack&#x3D;[2(75),3(71),4(69)]</li>
<li>ans&#x3D;[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;5 时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:&#x3D;5−4 和 ans[3]:&#x3D;5−3，将 5 进栈。</p>
<ul>
<li>stack&#x3D;[2(75),5(72)]</li>
<li>ans&#x3D;[1,1,0,2,1,0,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;6 时，由于 76 大于 72 和 75，因此依次移除栈顶元素 5 和 2，赋值 ans[5]:&#x3D;6−5 和 ans[2]:&#x3D;6−2，将 6 进栈。</p>
<ul>
<li>stack&#x3D;[6(76)]</li>
<li>ans&#x3D;[1,1,4,2,1,1,0,0]</li>
</ul>
</li>
<li><p>当 i&#x3D;7 时，由于 73 小于 76，因此将 7 进栈。</p>
<ul>
<li>stack&#x3D;[6(76),7(73)]</li>
<li>ans&#x3D;[1,1,4,2,1,1,0,0]</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        int length = temperatures.length;</span><br><span class="line">        int[] ans = new int[length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            int temperature = temperatures[i];</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                int prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;</span><br><span class="line">        int n = temperatures.size();</span><br><span class="line">        vector&lt;int&gt; ans(n);</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()]) &#123;</span><br><span class="line">                int previousIndex = s.top();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://icheng281.github.io/2024/04/17/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="icheng281">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勇者抽刃向强者的博客">
      <meta itemprop="description" content="计算机小白一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 勇者抽刃向强者的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/17/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">简化路径</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-17 10:04:31 / 修改时间：10:05:17" itemprop="dateCreated datePublished" datetime="2024-04-17T10:04:31+08:00">2024-04-17</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>912</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称。</p>
<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li>
<li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li>
<li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li>
</ul>
<p>返回简化后得到的 <strong>规范路径</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= path.length &lt;= 3000</code></li>
<li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li>
<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>
</ul>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>思路及算法</strong></p>
<p>我们首先将给定的字符串 <code>path</code> 根据 <code>/</code> 分割成一个由若干字符串组成的列表，记为 <code>names</code>。根据题目中规定的「规范路径的下述格式」，<code>names</code> 中包含的字符串只能为以下几种：</p>
<ul>
<li>空字符串。例如当出现多个连续的 <code>/</code>，就会分割出空字符串；</li>
<li>一个点<code> .</code>；</li>
<li>两个点 <code>..</code>；</li>
<li>只包含英文字母、数字或<code>_</code>的目录名。</li>
</ul>
<p>对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。</p>
<p>对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。</p>
<p>这样一来，我们只需要遍历 <code>names</code> 中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 <code>/</code> 进行连接，再在最前面加上 <code>/ </code>表示根目录，就可以得到简化后的规范路径。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string simplifyPath(string path) &#123;</span><br><span class="line">        auto split = [](const string&amp; s, char delim) -&gt; vector&lt;string&gt; &#123;</span><br><span class="line">            vector&lt;string&gt; ans;</span><br><span class="line">            string cur;</span><br><span class="line">            for (char ch: s) &#123;</span><br><span class="line">                if (ch == delim) &#123;</span><br><span class="line">                    ans.push_back(move(cur));</span><br><span class="line">                    cur.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur += ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(move(cur));</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; names = split(path, &#x27;/&#x27;);</span><br><span class="line">        vector&lt;string&gt; stack;</span><br><span class="line">        for (string&amp; name: names) &#123;</span><br><span class="line">            if (name == &quot;..&quot;) &#123;</span><br><span class="line">                if (!stack.empty()) &#123;</span><br><span class="line">                    stack.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!name.empty() &amp;&amp; name != &quot;.&quot;) &#123;</span><br><span class="line">                stack.push_back(move(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        if (stack.empty()) &#123;</span><br><span class="line">            ans = &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (string&amp; name: stack) &#123;</span><br><span class="line">                ans += &quot;/&quot; + move(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String simplifyPath(String path) &#123;</span><br><span class="line">        String[] names = path.split(&quot;/&quot;);</span><br><span class="line">        Deque&lt;String&gt; stack = new ArrayDeque&lt;String&gt;();</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            if (&quot;..&quot;.equals(name)) &#123;</span><br><span class="line">                if (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (name.length() &gt; 0 &amp;&amp; !&quot;.&quot;.equals(name)) &#123;</span><br><span class="line">                stack.offerLast(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer ans = new StringBuffer();</span><br><span class="line">        if (stack.isEmpty()) &#123;</span><br><span class="line">            ans.append(&#x27;/&#x27;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                ans.append(&#x27;/&#x27;);</span><br><span class="line">                ans.append(stack.pollFirst());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 <code>n</code> 是字符串<code> path</code> 的长度。</li>
<li>空间复杂度：O(n)。我们需要 O(n) 的空间存储 <code>names</code> 中的所有字符串。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">icheng281</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">102k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:11</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
