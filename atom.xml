<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勇者抽刃向强者的博客</title>
  
  <subtitle>梦是现实的延续，现实是梦的终结</subtitle>
  <link href="https://icheng281.github.io/atom.xml" rel="self"/>
  
  <link href="https://icheng281.github.io/"/>
  <updated>2024-05-10T02:37:40.019Z</updated>
  <id>https://icheng281.github.io/</id>
  
  <author>
    <name>icheng281</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>课程表II</title>
    <link href="https://icheng281.github.io/2024/05/10/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/"/>
    <id>https://icheng281.github.io/2024/05/10/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/</id>
    <published>2024-05-10T02:34:54.000Z</published>
    <updated>2024-05-10T02:37:40.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程表II"><a href="#课程表II" class="headerlink" title="课程表II"></a>课程表II</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><ul><li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有<strong>已经搜索完成的节点</strong>。</p><p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 存储有向图</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span><br><span class="line">    vector&lt;int&gt; visited;</span><br><span class="line">    // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    // 判断有向图中是否有环</span><br><span class="line">    bool valid = true;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int u) &#123;</span><br><span class="line">        // 将节点标记为「搜索中」</span><br><span class="line">        visited[u] = 1;</span><br><span class="line">        // 搜索其相邻节点</span><br><span class="line">        // 只要发现有环，立刻停止搜索</span><br><span class="line">        for (int v: edges[u]) &#123;</span><br><span class="line">            // 如果「未搜索」那么搜索相邻节点</span><br><span class="line">            if (visited[v] == 0) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if (!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果「搜索中」说明找到了环</span><br><span class="line">            else if (visited[v] == 1) &#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将节点标记为「已完成」</span><br><span class="line">        visited[u] = 2;</span><br><span class="line">        // 将节点入栈</span><br><span class="line">        result.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span><br><span class="line">        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!valid) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果没有环，那么就有拓扑排序</span><br><span class="line">        // 注意下标 0 为栈底，因此需要将数组反序输出</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 存储有向图</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span><br><span class="line">    int[] visited;</span><br><span class="line">    // 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span><br><span class="line">    int[] result;</span><br><span class="line">    // 判断有向图中是否有环</span><br><span class="line">    boolean valid = true;</span><br><span class="line">    // 栈下标</span><br><span class="line">    int index;</span><br><span class="line"></span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = new int[numCourses];</span><br><span class="line">        result = new int[numCourses];</span><br><span class="line">        index = numCourses - 1;</span><br><span class="line">        for (int[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[1]).add(info[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span><br><span class="line">        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            if (visited[i] == 0) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!valid) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果没有环，那么就有拓扑排序</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int u) &#123;</span><br><span class="line">        // 将节点标记为「搜索中」</span><br><span class="line">        visited[u] = 1;</span><br><span class="line">        // 搜索其相邻节点</span><br><span class="line">        // 只要发现有环，立刻停止搜索</span><br><span class="line">        for (int v: edges.get(u)) &#123;</span><br><span class="line">            // 如果「未搜索」那么搜索相邻节点</span><br><span class="line">            if (visited[v] == 0) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if (!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果「搜索中」说明找到了环</span><br><span class="line">            else if (visited[v] == 1) &#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将节点标记为「已完成」</span><br><span class="line">        visited[u] = 2;</span><br><span class="line">        // 将节点入栈</span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: O(n+m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: O(n+m)。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n) 的空间存储节点状态、最终答案等。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 存储有向图</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    // 存储每个节点的入度</span><br><span class="line">    vector&lt;int&gt; indeg;</span><br><span class="line">    // 存储答案</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        // 将所有入度为 0 的节点放入队列中</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 从队首取出一个节点</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            // 放入答案中</span><br><span class="line">            result.push_back(u);</span><br><span class="line">            for (int v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result.size() != numCourses) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 存储有向图</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    // 存储每个节点的入度</span><br><span class="line">    int[] indeg;</span><br><span class="line">    // 存储答案</span><br><span class="line">    int[] result;</span><br><span class="line">    // 答案下标</span><br><span class="line">    int index;</span><br><span class="line"></span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = new int[numCourses];</span><br><span class="line">        result = new int[numCourses];</span><br><span class="line">        index = 0;</span><br><span class="line">        for (int[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[1]).add(info[0]);</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        // 将所有入度为 0 的节点放入队列中</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            // 从队首取出一个节点</span><br><span class="line">            int u = queue.poll();</span><br><span class="line">            // 放入答案中</span><br><span class="line">            result[index++] = u;</span><br><span class="line">            for (int v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index != numCourses) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: O(n+m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: O(n+m)。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在广度优先搜索的过程中，我们需要最多 O(n) 的队列空间（迭代）进行广度优先搜索，并且还需要若干个 O(n) 的空间存储节点入度、最终答案等。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程表II&quot;&gt;&lt;a href=&quot;#课程表II&quot; class=&quot;headerlink&quot; title=&quot;课程表II&quot;&gt;&lt;/a&gt;课程表II&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>除法求值</title>
    <link href="https://icheng281.github.io/2024/05/10/%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>https://icheng281.github.io/2024/05/10/%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2024-05-10T02:33:45.000Z</published>
    <updated>2024-05-10T02:38:11.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a>除法求值</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p><strong>注意：</strong>未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br><span class="line">注意：x 是未定义的 =&gt; -1.0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">输出：[0.50000,2.00000,-1.00000,-1.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= equations.length &lt;= 20</code></li><li><code>equations[i].length == 2</code></li><li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li><li><code>values.length == equations.length</code></li><li><code>0.0 &lt; values[i] &lt;= 20.0</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li><li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以将整个问题建模成一张图：给定图中的一些点（变量），以及某些边的权值（两个变量的比值），试对任意两点（两个变量）求出其路径长（两个变量的比值）。</p><p>因此，我们首先需要遍历 equations 数组，找出其中所有不同的字符串，并通过哈希表将每个不同的字符串映射成整数。</p><p>在构建完图之后，对于任何一个查询，就可以从起点出发，通过广度优先搜索的方式，不断更新起点与当前点之间的路径长度，直到搜索到终点为止。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        int nvars = 0;</span><br><span class="line">        unordered_map&lt;string, int&gt; variables;</span><br><span class="line"></span><br><span class="line">        int n = equations.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (variables.find(equations[i][0]) == variables.end()) &#123;</span><br><span class="line">                variables[equations[i][0]] = nvars++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (variables.find(equations[i][1]) == variables.end()) &#123;</span><br><span class="line">                variables[equations[i][1]] = nvars++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对于每个点，存储其直接连接到的所有点及对应的权值</span><br><span class="line">        vector&lt;vector&lt;pair&lt;int, double&gt;&gt;&gt; edges(nvars);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int va = variables[equations[i][0]], vb = variables[equations[i][1]];</span><br><span class="line">            edges[va].push_back(make_pair(vb, values[i]));</span><br><span class="line">            edges[vb].push_back(make_pair(va, 1.0 / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;double&gt; ret;</span><br><span class="line">        for (const auto&amp; q: queries) &#123;</span><br><span class="line">            double result = -1.0;</span><br><span class="line">            if (variables.find(q[0]) != variables.end() &amp;&amp; variables.find(q[1]) != variables.end()) &#123;</span><br><span class="line">                int ia = variables[q[0]], ib = variables[q[1]];</span><br><span class="line">                if (ia == ib) &#123;</span><br><span class="line">                    result = 1.0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    queue&lt;int&gt; points;</span><br><span class="line">                    points.push(ia);</span><br><span class="line">                    vector&lt;double&gt; ratios(nvars, -1.0);</span><br><span class="line">                    ratios[ia] = 1.0;</span><br><span class="line"></span><br><span class="line">                    while (!points.empty() &amp;&amp; ratios[ib] &lt; 0) &#123;</span><br><span class="line">                        int x = points.front();</span><br><span class="line">                        points.pop();</span><br><span class="line"></span><br><span class="line">                        for (const auto [y, val]: edges[x]) &#123;</span><br><span class="line">                            if (ratios[y] &lt; 0) &#123;</span><br><span class="line">                                ratios[y] = ratios[x] * val;</span><br><span class="line">                                points.push(y);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = ratios[ib];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        int nvars = 0;</span><br><span class="line">        Map&lt;String, Integer&gt; variables = new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int n = equations.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (!variables.containsKey(equations.get(i).get(0))) &#123;</span><br><span class="line">                variables.put(equations.get(i).get(0), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!variables.containsKey(equations.get(i).get(1))) &#123;</span><br><span class="line">                variables.put(equations.get(i).get(1), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对于每个点，存储其直接连接到的所有点及对应的权值</span><br><span class="line">        List&lt;Pair&gt;[] edges = new List[nvars];</span><br><span class="line">        for (int i = 0; i &lt; nvars; i++) &#123;</span><br><span class="line">            edges[i] = new ArrayList&lt;Pair&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));</span><br><span class="line">            edges[va].add(new Pair(vb, values[i]));</span><br><span class="line">            edges[vb].add(new Pair(va, 1.0 / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int queriesCount = queries.size();</span><br><span class="line">        double[] ret = new double[queriesCount];</span><br><span class="line">        for (int i = 0; i &lt; queriesCount; i++) &#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            double result = -1.0;</span><br><span class="line">            if (variables.containsKey(query.get(0)) &amp;&amp; variables.containsKey(query.get(1))) &#123;</span><br><span class="line">                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));</span><br><span class="line">                if (ia == ib) &#123;</span><br><span class="line">                    result = 1.0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Queue&lt;Integer&gt; points = new LinkedList&lt;Integer&gt;();</span><br><span class="line">                    points.offer(ia);</span><br><span class="line">                    double[] ratios = new double[nvars];</span><br><span class="line">                    Arrays.fill(ratios, -1.0);</span><br><span class="line">                    ratios[ia] = 1.0;</span><br><span class="line"></span><br><span class="line">                    while (!points.isEmpty() &amp;&amp; ratios[ib] &lt; 0) &#123;</span><br><span class="line">                        int x = points.poll();</span><br><span class="line">                        for (Pair pair : edges[x]) &#123;</span><br><span class="line">                            int y = pair.index;</span><br><span class="line">                            double val = pair.value;</span><br><span class="line">                            if (ratios[y] &lt; 0) &#123;</span><br><span class="line">                                ratios[y] = ratios[x] * val;</span><br><span class="line">                                points.offer(y);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = ratios[ib];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair &#123;</span><br><span class="line">    int index;</span><br><span class="line">    double value;</span><br><span class="line"></span><br><span class="line">    Pair(int index, double value) &#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(ML+Q⋅(L+M))，其中 M 为边的数量，Q 为询问的数量，L 为字符串的平均长度。构建图时，需要处理 M 条边，每条边都涉及到 O(L) 的字符串比较；处理查询时，每次查询首先要进行一次 O(L) 的比较，然后至多遍历 O(M) 条边。</p></li><li><p>空间复杂度：O(NL+M)，其中 N 为点的数量，M 为边的数量，L 为字符串的平均长度。为了将每个字符串映射到整数，需要开辟空间为 O(NL) 的哈希表；随后，需要花费 O(M) 的空间存储每条边的权重；处理查询时，还需要 O(N) 的空间维护访问队列。最终，总的复杂度为 O(NL+M+N)&#x3D;O(NL+M)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;除法求值&quot;&gt;&lt;a href=&quot;#除法求值&quot; class=&quot;headerlink&quot; title=&quot;除法求值&quot;&gt;&lt;/a&gt;除法求值&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1.题目内</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>克隆图</title>
    <link href="https://icheng281.github.io/2024/05/10/%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://icheng281.github.io/2024/05/10/%E5%85%8B%E9%9A%86%E5%9B%BE/</id>
    <published>2024-05-10T02:33:24.000Z</published>
    <updated>2024-05-10T02:37:03.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a>克隆图</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>这张图中的节点数在 <code>[0, 100]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li>每个节点值 <code>Node.val</code> 都是唯一的，</li><li>图中没有重复的边，也没有自环。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先遍历"><a href="#（1）深度优先遍历" class="headerlink" title="（1）深度优先遍历"></a>（1）深度优先遍历</h3><p><strong>思路及算法</strong></p><p>对于本题而言，我们需要明确图的深拷贝是在做什么，对于一张图而言，它的深拷贝即构建一张与原图结构，值均一样的图，但是其中的节点不再是原来图节点的引用。因此，为了深拷贝出整张图，我们需要知道整张图的结构以及对应节点的值。</p><p>由于题目只给了我们一个节点的引用，因此为了知道整张图的结构以及对应节点的值，我们需要从给定的节点出发，进行「图的遍历」，并在遍历的过程中完成图的深拷贝。</p><p>为了避免在深拷贝时陷入死循环，我们需要理解图的结构。对于一张无向图，任何给定的无向边都可以表示为两个有向边，即如果节点 A 和节点 B 之间存在无向边，则表示该图具有从节点 A 到节点 B 的有向边和从节点 B 到节点 A 的有向边。</p><p><img src="https://assets.leetcode-cn.com/solution-static/133/1.png" alt="fig1"></p><p>流程如下：</p><ol><li><p>使用一个哈希表存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。</p></li><li><p>从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。</p><p>如下图，我们给定无向边边 A - B，表示 A 能连接到 B，且 B 能连接到 A。如果不对访问过的节点做标记，则会陷入死循环中。</p></li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/133/2.png" alt="fig2"></p><ol start="3"><li>如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。注意：在进入递归之前，必须先创建克隆节点并保存在哈希表中。如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/133/3.png" alt="fig3"></p><ol start="4"><li>递归调用每个节点的邻接点。每个节点递归调用的次数等于邻接点的数量，每一次调用返回其对应邻接点的克隆节点，最终返回这些克隆邻接点的列表，将其放入对应克隆节点的邻接表中。这样就可以克隆给定的节点和其邻接点。</li></ol><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private HashMap &lt;Node, Node&gt; visited = new HashMap &lt;&gt; ();</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br><span class="line">        if (visited.containsKey(node)) &#123;</span><br><span class="line">            return visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span><br><span class="line">        Node cloneNode = new Node(node.val, new ArrayList());</span><br><span class="line">        // 哈希表存储</span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的邻居并更新克隆节点的邻居列表</span><br><span class="line">        for (Node neighbor: node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        return cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br><span class="line">        if (visited.find(node) != visited.end()) &#123;</span><br><span class="line">            return visited[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span><br><span class="line">        Node* cloneNode = new Node(node-&gt;val);</span><br><span class="line">        // 哈希表存储</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的邻居并更新克隆节点的邻居列表</span><br><span class="line">        for (auto&amp; neighbor: node-&gt;neighbors) &#123;</span><br><span class="line">            cloneNode-&gt;neighbors.emplace_back(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        return cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N)，其中 N 表示节点数量。深度优先搜索遍历图的过程中每个节点只会被访问一次。</p></li><li><p>空间复杂度：O(N)。存储克隆节点和原节点的哈希表需要 O(N) 的空间，递归调用栈需要 O(H) 的空间，其中 H 是图的深度，经过放缩可以得到 O(H)&#x3D;O(N)，因此总体空间复杂度为 O(N)。</p></li></ul><h3 id="（2）广度优先遍历"><a href="#（2）广度优先遍历" class="headerlink" title="（2）广度优先遍历"></a>（2）广度优先遍历</h3><p>同样，我们也可以用广度优先搜索来进行「图的遍历」。</p><p><img src="https://assets.leetcode-cn.com/solution-static/133/4.png" alt="fig4"></p><p>流程如下：</p><ol><li><p>使用一个哈希表 visited 存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。</p></li><li><p>将题目给定的节点添加到队列。克隆该节点并存储到哈希表中。</p></li><li><p>每次从队列首部取出一个节点，遍历该节点的所有邻接点。如果某个邻接点已被访问，则该邻接点一定在 visited 中，那么从 visited 获得该邻接点，否则创建一个新的节点存储在 visited 中，并将邻接点添加到队列。将克隆的邻接点添加到克隆图对应节点的邻接表中。重复上述操作直到队列为空，则整个图遍历结束。</p></li></ol><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Node, Node&gt; visited = new HashMap();</span><br><span class="line"></span><br><span class="line">        // 将题目给定的节点添加到队列</span><br><span class="line">        LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt; ();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        // 克隆第一个节点并存储到哈希表中</span><br><span class="line">        visited.put(node, new Node(node.val, new ArrayList()));</span><br><span class="line"></span><br><span class="line">        // 广度优先搜索</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            // 取出队列的头节点</span><br><span class="line">            Node n = queue.remove();</span><br><span class="line">            // 遍历该节点的邻居</span><br><span class="line">            for (Node neighbor: n.neighbors) &#123;</span><br><span class="line">                if (!visited.containsKey(neighbor)) &#123;</span><br><span class="line">                    // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                    visited.put(neighbor, new Node(neighbor.val, new ArrayList()));</span><br><span class="line">                    // 将邻居节点加入队列中</span><br><span class="line">                    queue.add(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                // 更新当前节点的邻居列表</span><br><span class="line">                visited.get(n).neighbors.add(visited.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">        // 将题目给定的节点添加到队列</span><br><span class="line">        queue&lt;Node*&gt; Q;</span><br><span class="line">        Q.push(node);</span><br><span class="line">        // 克隆第一个节点并存储到哈希表中</span><br><span class="line">        visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        // 广度优先搜索</span><br><span class="line">        while (!Q.empty()) &#123;</span><br><span class="line">            // 取出队列的头节点</span><br><span class="line">            auto n = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            // 遍历该节点的邻居</span><br><span class="line">            for (auto&amp; neighbor: n-&gt;neighbors) &#123;</span><br><span class="line">                if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                    // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                    visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                    // 将邻居节点加入队列中</span><br><span class="line">                    Q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                // 更新当前节点的邻居列表</span><br><span class="line">                visited[n]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return visited[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N)，其中 N 表示节点数量。广度优先搜索遍历图的过程中每个节点只会被访问一次。</p></li><li><p>空间复杂度：O(N)。哈希表使用 O(N) 的空间。广度优先搜索中的队列在最坏情况下会达到 O(N) 的空间复杂度，因此总体空间复杂度为 O(N)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;克隆图&quot;&gt;&lt;a href=&quot;#克隆图&quot; class=&quot;headerlink&quot; title=&quot;克隆图&quot;&gt;&lt;/a&gt;克隆图&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1.题目内容&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>被围绕的区域</title>
    <link href="https://icheng281.github.io/2024/05/10/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>https://icheng281.github.io/2024/05/10/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2024-05-10T02:32:56.000Z</published>
    <updated>2024-05-10T02:35:58.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 <code>O</code> 修改为字母 <code>A</code>。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int n, m;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#x27;O&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = &#x27;A&#x27;;</span><br><span class="line">        dfs(board, x + 1, y);</span><br><span class="line">        dfs(board, x - 1, y);</span><br><span class="line">        dfs(board, x, y + 1);</span><br><span class="line">        dfs(board, x, y - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        n = board.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[0].size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, 0);</span><br><span class="line">            dfs(board, i, m - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            dfs(board, 0, i);</span><br><span class="line">            dfs(board, n - 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int n, m;</span><br><span class="line"></span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[0].length;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, 0);</span><br><span class="line">            dfs(board, i, m - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            dfs(board, 0, i);</span><br><span class="line">            dfs(board, n - 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(char[][] board, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#x27;O&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = &#x27;A&#x27;;</span><br><span class="line">        dfs(board, x + 1, y);</span><br><span class="line">        dfs(board, x - 1, y);</span><br><span class="line">        dfs(board, x, y + 1);</span><br><span class="line">        dfs(board, x, y - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 <code>O</code> 修改为字母 <code>A</code>。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int n = board.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].size();</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (board[i][0] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(i, 0);</span><br><span class="line">                board[i][0] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][m - 1] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(i, m - 1);</span><br><span class="line">                board[i][m - 1] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            if (board[0][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(0, i);</span><br><span class="line">                board[0][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[n - 1][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(n - 1, i);</span><br><span class="line">                board[n - 1][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int x = que.front().first, y = que.front().second;</span><br><span class="line">            que.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                que.emplace(mx, my);</span><br><span class="line">                board[mx][my] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    int[] dy = &#123;0, 0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">        int n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].length;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (board[i][0] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;i, 0&#125;);</span><br><span class="line">                board[i][0] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][m - 1] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;i, m - 1&#125;);</span><br><span class="line">                board[i][m - 1] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            if (board[0][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;0, i&#125;);</span><br><span class="line">                board[0][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[n - 1][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;n - 1, i&#125;);</span><br><span class="line">                board[n - 1][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] cell = queue.poll();</span><br><span class="line">            int x = cell[0], y = cell[1];</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(new int[]&#123;mx, my&#125;);</span><br><span class="line">                board[mx][my] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;被围绕的区域&quot;&gt;&lt;a href=&quot;#被围绕的区域&quot; class=&quot;headerlink&quot; title=&quot;被围绕的区域&quot;&gt;&lt;/a&gt;被围绕的区域&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>课程表</title>
    <link href="https://icheng281.github.io/2024/05/09/%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>https://icheng281.github.io/2024/05/09/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</id>
    <published>2024-05-09T08:58:53.000Z</published>
    <updated>2024-05-09T08:59:59.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）广度优先遍历"><a href="#（1）广度优先遍历" class="headerlink" title="（1）广度优先遍历"></a>（1）广度优先遍历</h3><p><strong>思路及算法</strong></p><ol><li>统计课程安排图中每个节点的入度，生成 入度表 indegrees。</li><li>借助一个队列 queue，将所有入度为 0 的节点入队。</li><li>当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：<ul><li>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -&#x3D; 1。</li><li>当入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。</li></ul></li><li>在每次 pre 出队时，执行 numCourses–；<ul><li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。</li><li>因此，拓扑排序出队次数等于课程个数，返回 numCourses &#x3D;&#x3D; 0 判断课程是否可以成功安排。</li></ul></li></ol><p><img src="https://pic.leetcode-cn.com/90794a4bf4034a277621d9ca33f2df25c40f7ff0d9d47044396c44d166920a99-Picture1.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/bd2f99fca16bd3a626153945a28ea8a75b151e6404d5525ad30202e19caab05c-Picture2.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/cb061aa43f1fcd9ca23069a5712a58a5ace8636deaaab3e1536d14d173b0cdde-Picture3.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/66300cbc4c966c866cd56934b74caaa1770cc25c8d80edf4c41eb00f67699155-Picture4.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/7dc96bec8f3a5bb2b8bd75a3c7343b2753a70aedf3a7ffefa0019aa235fb9174-Picture5.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/b907e91e670a0a077154f0b7b2a483f19cd6952f790ed2f1a3bab9ce389ca408-Picture6.png" alt="img"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        int[] indegrees = new int[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = new ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)</span><br><span class="line">            adjacency.add(new ArrayList&lt;&gt;());</span><br><span class="line">        // Get the indegree and adjacency of every course.</span><br><span class="line">        for(int[] cp : prerequisites) &#123;</span><br><span class="line">            indegrees[cp[0]]++;</span><br><span class="line">            adjacency.get(cp[1]).add(cp[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        // Get all the courses with the indegree of 0.</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)</span><br><span class="line">            if(indegrees[i] == 0) queue.add(i);</span><br><span class="line">        // BFS TopSort.</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            int pre = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            for(int cur : adjacency.get(pre))</span><br><span class="line">                if(--indegrees[cur] == 0) queue.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return numCourses == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</li><li>空间复杂度 O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。</li></ul><h3 id="（2）深度优先遍历"><a href="#（2）深度优先遍历" class="headerlink" title="（2）深度优先遍历"></a>（2）深度优先遍历</h3><p><strong>思路及算法</strong></p><ol><li>借助一个标志列表 flags，用于判断每个节点 i （课程）的状态：<ul><li>未被 DFS 访问：i &#x3D;&#x3D; 0；</li><li>已被其他节点启动的 DFS 访问：i &#x3D;&#x3D; -1；</li><li>已被当前节点启动的 DFS 访问：i &#x3D;&#x3D; 1。</li></ul></li><li>对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。DFS 流程；<ul><li>终止条件：<ul><li>当 flag[i] &#x3D;&#x3D; -1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True。</li><li>当 flag[i] &#x3D;&#x3D; 1，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即 课程安排图有环 ，直接返回 False。</li></ul></li><li>将当前访问节点 i 对应 flag[i] 置 1，即标记其被本轮 DFS 访问过；</li><li>递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 False；</li><li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 −1 并返回 True。</li></ul></li><li>若整个图 DFS 结束并未发现环，返回 True。</li></ol><p><img src="https://pic.leetcode-cn.com/787383a8e6ed9d18499837e3eb94c10a9e3de64a1f76259ded74a635b2ef0b12-Picture1.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/ec5b41cea11ccbba143a4c0b4228ab6f099959dba0dc8c63271002d26daf676d-Picture2.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/ef64799948518388fe829caf9338c9d079516dfa8fad0d6816774c551f6308e8-Picture3.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/90842d993bc53d5a3ea4ad51f96b99a547c75bf5ae2431702567ae83241d97bd-Picture4.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/b2d7e9eea81fa4fa3e610a60234b893e18c16b1771ec7d9a15c22a8102b03f4f-Picture5.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/78e90e8f3ddde37440ac871b0c3bd8e27d94548b48da702598c5fe129bdac61c-Picture6.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/14417b800e1dc9fe12f974e896e5394acb798ca35bd6dfad21ebbd92f63a2827-Picture7.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/6130b9953454bdb48b504a1ecbf76ee1f3b4a0f88bc9de0cf93557c0f8dc85c3-Picture8.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/722bc45d5dbe89105ad8c8ed09ee237b64e0ef681e09b55bdb083f7f1cffa26e-Picture9.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/ccb8c7d911011f3f048683650534ad4e9981ee39c9becd7aa6133c99bac2fa8b-Picture10.png" alt="img"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)</span><br><span class="line">            adjacency.add(new ArrayList&lt;&gt;());</span><br><span class="line">        int[] flags = new int[numCourses];</span><br><span class="line">        for(int[] cp : prerequisites)</span><br><span class="line">            adjacency.get(cp[1]).add(cp[0]);</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)</span><br><span class="line">            if(!dfs(adjacency, flags, i)) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean dfs(List&lt;List&lt;Integer&gt;&gt; adjacency, int[] flags, int i) &#123;</span><br><span class="line">        if(flags[i] == 1) return false;</span><br><span class="line">        if(flags[i] == -1) return true;</span><br><span class="line">        flags[i] = 1;</span><br><span class="line">        for(Integer j : adjacency.get(i))</span><br><span class="line">            if(!dfs(adjacency, flags, j)) return false;</span><br><span class="line">        flags[i] = -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</li><li>空间复杂度 O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程表&quot;&gt;&lt;a href=&quot;#课程表&quot; class=&quot;headerlink&quot; title=&quot;课程表&quot;&gt;&lt;/a&gt;课程表&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1.题目内容&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>实现前缀树</title>
    <link href="https://icheng281.github.io/2024/05/09/%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://icheng281.github.io/2024/05/09/%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/</id>
    <published>2024-05-09T08:55:44.000Z</published>
    <updated>2024-05-09T08:59:37.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现前缀树"><a href="#实现前缀树" class="headerlink" title="实现前缀树"></a>实现前缀树</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>T（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10000</code> 次</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p><strong>思路及算法</strong></p><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。</li><li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li></ul><p><strong>插入字符串</strong></p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li><li>子节点不存在。创建一个新的子节点，记录在 children数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。<br>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</li></ul><p><strong>查找前缀</strong></p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li><li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li><li>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</li></ul><p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd\textit{isEnd}isEnd 为真，则说明字典树中存在该字符串。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Trie &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    bool isEnd;</span><br><span class="line"></span><br><span class="line">    Trie* searchPrefix(string prefix) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        for (char ch : prefix) &#123;</span><br><span class="line">            ch -= &#x27;a&#x27;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Trie() : children(26), isEnd(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        for (char ch : word) &#123;</span><br><span class="line">            ch -= &#x27;a&#x27;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                node-&gt;children[ch] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        Trie* node = this-&gt;searchPrefix(word);</span><br><span class="line">        return node != nullptr &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        return this-&gt;searchPrefix(prefix) != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Trie &#123;</span><br><span class="line">    private Trie[] children;</span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        children = new Trie[26];</span><br><span class="line">        isEnd = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        Trie node = this;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char ch = word.charAt(i);</span><br><span class="line">            int index = ch - &#x27;a&#x27;;</span><br><span class="line">            if (node.children[index] == null) &#123;</span><br><span class="line">                node.children[index] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        Trie node = searchPrefix(word);</span><br><span class="line">        return node != null &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        return searchPrefix(prefix) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Trie searchPrefix(String prefix) &#123;</span><br><span class="line">        Trie node = this;</span><br><span class="line">        for (int i = 0; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            char ch = prefix.charAt(i);</span><br><span class="line">            int index = ch - &#x27;a&#x27;;</span><br><span class="line">            if (node.children[index] == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：初始化为 O(1)，其余操作为 O(∣S∣)，其中 ∣S∣ 是每次插入或查询的字符串的长度。</p></li><li><p>空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣ 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ&#x3D;26。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实现前缀树&quot;&gt;&lt;a href=&quot;#实现前缀树&quot; class=&quot;headerlink&quot; title=&quot;实现前缀树&quot;&gt;&lt;/a&gt;实现前缀树&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>腐烂的橘子</title>
    <link href="https://icheng281.github.io/2024/05/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>https://icheng281.github.io/2024/05/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2024-05-08T02:17:34.000Z</published>
    <updated>2024-05-08T02:22:45.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h4 id="多源广度优先搜索"><a href="#多源广度优先搜索" class="headerlink" title="多源广度优先搜索"></a>多源广度优先搜索</h4><p><strong>思路及算法</strong></p><p>观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。</p><p>假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(我们令其为超级源点)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 −1 ，那么按照广度优先搜索的算法，下一分钟也就是第 0 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x] [y]其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</p><p>为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 cnt&#x3D;cnt−1 ，最后搜索结束时如果 cnt 大于 0 ，说明有新鲜橘子没被腐烂，返回 −1 ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 1 改为 2，最后看网格中是否由值为 1 即新鲜的橘子即可。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int dis[10][10];</span><br><span class="line">    int dir_x[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    int dir_y[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt;Q;</span><br><span class="line">        memset(dis, -1, sizeof(dis));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        int n = (int)grid.size(), m = (int)grid[0].size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 2) &#123;</span><br><span class="line">                    Q.emplace(i, j);</span><br><span class="line">                    dis[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (grid[i][j] == 1) &#123;</span><br><span class="line">                    cnt += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!Q.empty())&#123;</span><br><span class="line">            auto [r, c] = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int tx = r + dir_x[i];</span><br><span class="line">                int ty = c + dir_y[i];</span><br><span class="line">                if (tx &lt; 0|| tx &gt;= n || ty &lt; 0|| ty &gt;= m || ~dis[tx][ty] || !grid[tx][ty]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                dis[tx][ty] = dis[r][c] + 1;</span><br><span class="line">                Q.emplace(tx, ty);</span><br><span class="line">                if (grid[tx][ty] == 1) &#123;</span><br><span class="line">                    cnt -= 1;</span><br><span class="line">                    ans = dis[tx][ty];</span><br><span class="line">                    if (!cnt) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int[] dr = new int[]&#123;-1, 0, 1, 0&#125;;</span><br><span class="line">    int[] dc = new int[]&#123;0, -1, 0, 1&#125;;</span><br><span class="line"></span><br><span class="line">    public int orangesRotting(int[][] grid) &#123;</span><br><span class="line">        int R = grid.length, C = grid[0].length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; depth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int r = 0; r &lt; R; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; C; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == 2) &#123;</span><br><span class="line">                    int code = r * C + c;</span><br><span class="line">                    queue.add(code);</span><br><span class="line">                    depth.put(code, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int code = queue.remove();</span><br><span class="line">            int r = code / C, c = code % C;</span><br><span class="line">            for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                int nr = r + dr[k];</span><br><span class="line">                int nc = c + dc[k];</span><br><span class="line">                if (0 &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; 0 &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == 1) &#123;</span><br><span class="line">                    grid[nr][nc] = 2;</span><br><span class="line">                    int ncode = nr * C + nc;</span><br><span class="line">                    queue.add(ncode);</span><br><span class="line">                    depth.put(ncode, depth.get(code) + 1);</span><br><span class="line">                    ans = depth.get(ncode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] row: grid) &#123;</span><br><span class="line">            for (int v: row) &#123;</span><br><span class="line">                if (v == 1) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nm)。即进行一次广度优先搜索的时间，其中 n,m 分别为 grid 的行数与列数。</p></li><li><p>空间复杂度：O(nm)。需要额外的 dis 数组记录每个新鲜橘子被腐烂的最短时间，大小为 O(nm)，且广度优先搜索中队列里存放的状态最多不会超过 nm 个，最多需要 O(nm) 的空间，所以最后的空间复杂度为 O(nm)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;腐烂的橘子&quot;&gt;&lt;a href=&quot;#腐烂的橘子&quot; class=&quot;headerlink&quot; title=&quot;腐烂的橘子&quot;&gt;&lt;/a&gt;腐烂的橘子&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="https://icheng281.github.io/2024/05/08/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://icheng281.github.io/2024/05/08/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2024-05-08T02:17:07.000Z</published>
    <updated>2024-05-08T02:23:09.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><p><img src="https://pic.leetcode-cn.com/5dae0de2a06f4eae5113f9cadfa5c51bbcf0b9347c5861aa73c93d7bc1d50b34-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/61a98091fe75de107bf886a608e87d5bb29d810b9e7eb1e00c541f49194ea543-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/6d060f275561dc390841f78d85124fd193efb0801ea2dc865b2767f1093e4f3a-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/233368eab82832268c3c7266fd7fe65c78626de9fd89cb90b3f36a7b4e52860d-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/bf055c3d5f6b310f6a110ada65d503de6d7793276f5638731c81c53b4276b835-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/195ba530a5350e0a8f8e372319d061c85316c1064017d5c00d7cfc2b0c055de6-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/c21a88bde9450ad83d6164c2df4677b16154fa5990408459a2a45982b9cd70fd-image.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/0cfddec2d15ed9a56c434f470ff07eb3dfc83dccbda0160583d1bce469077274-image.png" alt="img"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) &#123;</span><br><span class="line">        int nr = grid.size();</span><br><span class="line">        int nc = grid[0].size();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = &#x27;0&#x27;;</span><br><span class="line">        if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &#x27;1&#x27;) dfs(grid, r - 1, c);</span><br><span class="line">        if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &#x27;1&#x27;) dfs(grid, r + 1, c);</span><br><span class="line">        if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &#x27;1&#x27;) dfs(grid, r, c - 1);</span><br><span class="line">        if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &#x27;1&#x27;) dfs(grid, r, c + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int nr = grid.size();</span><br><span class="line">        if (!nr) return 0;</span><br><span class="line">        int nc = grid[0].size();</span><br><span class="line"></span><br><span class="line">        int num_islands = 0;</span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(char[][] grid, int r, int c) &#123;</span><br><span class="line">        int nr = grid.length;</span><br><span class="line">        int nc = grid[0].length;</span><br><span class="line"></span><br><span class="line">        if (r &lt; 0 || c &lt; 0 || r &gt;= nr || c &gt;= nc || grid[r][c] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = &#x27;0&#x27;;</span><br><span class="line">        dfs(grid, r - 1, c);</span><br><span class="line">        dfs(grid, r + 1, c);</span><br><span class="line">        dfs(grid, r, c - 1);</span><br><span class="line">        dfs(grid, r, c + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        if (grid == null || grid.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nr = grid.length;</span><br><span class="line">        int nc = grid[0].length;</span><br><span class="line">        int num_islands = 0;</span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p></li><li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>同样地，我们也可以使用广度优先搜索代替深度优先搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int nr = grid.size();</span><br><span class="line">        if (!nr) return 0;</span><br><span class="line">        int nc = grid[0].size();</span><br><span class="line"></span><br><span class="line">        int num_islands = 0;</span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = &#x27;0&#x27;;</span><br><span class="line">                    queue&lt;pair&lt;int, int&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    while (!neighbors.empty()) &#123;</span><br><span class="line">                        auto rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        int row = rc.first, col = rc.second;</span><br><span class="line">                        if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.push(&#123;row-1, col&#125;);</span><br><span class="line">                            grid[row-1][col] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+1, col&#125;);</span><br><span class="line">                            grid[row+1][col] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col-1&#125;);</span><br><span class="line">                            grid[row][col-1] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+1&#125;);</span><br><span class="line">                            grid[row][col+1] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        if (grid == null || grid.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nr = grid.length;</span><br><span class="line">        int nc = grid[0].length;</span><br><span class="line">        int num_islands = 0;</span><br><span class="line"></span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = &#x27;0&#x27;;</span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = new LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(r * nc + c);</span><br><span class="line">                    while (!neighbors.isEmpty()) &#123;</span><br><span class="line">                        int id = neighbors.remove();</span><br><span class="line">                        int row = id / nc;</span><br><span class="line">                        int col = id % nc;</span><br><span class="line">                        if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.add((row-1) * nc + col);</span><br><span class="line">                            grid[row-1][col] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.add((row+1) * nc + col);</span><br><span class="line">                            grid[row+1][col] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col-1);</span><br><span class="line">                            grid[row][col-1] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == &#x27;1&#x27;) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col+1);</span><br><span class="line">                            grid[row][col+1] = &#x27;0&#x27;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p></li><li><p>空间复杂度：O(min⁡(M,N))，在最坏情况下，整个网格均为陆地，队列的大小可以达到 min⁡(M,N)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;岛屿数量&quot;&gt;&lt;a href=&quot;#岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;岛屿数量&quot;&gt;&lt;/a&gt;岛屿数量&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1.题目内</summary>
      
    
    
    
    
    <category term="数据结构-图" scheme="https://icheng281.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>划分字母区间</title>
    <link href="https://icheng281.github.io/2024/05/08/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <id>https://icheng281.github.io/2024/05/08/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</id>
    <published>2024-05-08T02:16:38.000Z</published>
    <updated>2024-05-08T02:22:04.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><strong>思路及算法</strong></p><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。</p><p>在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。</p><ul><li><p>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start&#x3D;end&#x3D;0。</p></li><li><p>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 endc，则当前片段的结束下标一定不会小于 endc，因此令 end&#x3D;max⁡(end,endc)。</p></li><li><p>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是[start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start&#x3D;end+1，继续寻找下一个片段。</p></li><li><p>重复上述过程，直到遍历完字符串。</p></li></ul><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><p>由于每个片段访问结束的标志是访问到下标 end，因此对于每个片段，可以保证当前片段中的每个字母都一定在当前片段中，不可能出现在其他片段，可以保证同一个字母只会出现在同一个片段。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        int[] last = new int[26];</span><br><span class="line">        int length = s.length();</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            last[s.charAt(i) - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; partition = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        int start = 0, end = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            end = Math.max(end, last[s.charAt(i) - &#x27;a&#x27;]);</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                partition.add(end - start + 1);</span><br><span class="line">                start = end + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; partitionLabels(string s) &#123;</span><br><span class="line">        int last[26];</span><br><span class="line">        int length = s.size();</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            last[s[i] - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; partition;</span><br><span class="line">        int start = 0, end = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            end = max(end, last[s[i] - &#x27;a&#x27;]);</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                partition.push_back(end - start + 1);</span><br><span class="line">                start = end + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。</p></li><li><p>空间复杂度：O(∣Σ∣)，其中 Σ 是字符串中的字符集。这道题中，字符串只包含小写字母，因此 ∣Σ∣&#x3D;26。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;划分字母区间&quot;&gt;&lt;a href=&quot;#划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;划分字母区间&quot;&gt;&lt;/a&gt;划分字母区间&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>环形子数组的最大和</title>
    <link href="https://icheng281.github.io/2024/05/07/%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://icheng281.github.io/2024/05/07/%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2024-05-07T03:08:02.000Z</published>
    <updated>2024-05-07T03:10:03.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a>环形子数组的最大和</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-2,3,-2]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 得到最大和 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,-3,5]</span><br><span class="line">输出：10</span><br><span class="line">解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,-2,2,-3]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>思路及算法</strong></p><p>求解普通数组的最大子数组和是求解环形数组的最大子数组和问题的子集。设数组长度为 n，下标从 0 开始，在环形情况中，答案可能包括以下两种情况：</p><ol><li>构成最大子数组和的子数组为 nums[i:j]，包括 nums[i] 到 nums[j−1] 共 j−i 个元素，其中 0≤i&lt;j≤n。</li><li>构成最大子数组和的子数组为 nums[0:i] 和 nums[j:n]，其中 0&lt;i&lt;j&lt;n。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/918/918_2.png" alt="pic2"></p><p>第一种情况的求解方法与求解普通数组的最大子数组和方法完全相同。</p><p>第二种情况中，答案可以分为两部分，nums[0:i] 为数组的某一前缀，nums[j:n] 为数组的某一后缀。求解时，我们可以枚举 j，固定 sum(nums[j:n]) 的值，然后找到右端点坐标范围在 [0,j−1] 的最大前缀和，将它们相加更新答案。</p><p>右端点坐标范围在 [0,i] 的最大前缀和可以用 leftMax[i] 表示，递推方程为：</p><p>leftMax[i]&#x3D;max⁡(leftMax[i−1],sum(nums[0:i+1])</p><p><img src="https://assets.leetcode-cn.com/solution-static/918/918_3.png" alt="pic3"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; leftMax(n);</span><br><span class="line">        // 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br><span class="line">        leftMax[0] = nums[0];</span><br><span class="line">        int leftSum = nums[0];</span><br><span class="line">        int pre = nums[0];</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            pre = max(pre + nums[i], nums[i]);</span><br><span class="line">            res = max(res, pre);</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">            leftMax[i] = max(leftMax[i - 1], leftSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 从右到左枚举后缀，固定后缀，选择最大前缀</span><br><span class="line">        int rightSum = 0;</span><br><span class="line">        for (int i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            rightSum += nums[i];</span><br><span class="line">            res = max(res, rightSum + leftMax[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubarraySumCircular(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] leftMax = new int[n];</span><br><span class="line">        // 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况</span><br><span class="line">        leftMax[0] = nums[0];</span><br><span class="line">        int leftSum = nums[0];</span><br><span class="line">        int pre = nums[0];</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, pre);</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - 1], leftSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 从右到左枚举后缀，固定后缀，选择最大前缀</span><br><span class="line">        int rightSum = 0;</span><br><span class="line">        for (int i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            rightSum += nums[i];</span><br><span class="line">            res = Math.max(res, rightSum + leftMax[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是 nums 的长度。求解第一种情况的时间复杂度为 O(n)，求解 leftMax 数组和枚举后缀的时间复杂度为 O(n)，因此总的时间复杂度为 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是 nums 的长度。过程中我们使用 leftMax 来存放最大前缀和。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环形子数组的最大和&quot;&gt;&lt;a href=&quot;#环形子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;环形子数组的最大和&quot;&gt;&lt;/a&gt;环形子数组的最大和&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>建立四叉树</title>
    <link href="https://icheng281.github.io/2024/05/07/%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91/"/>
    <id>https://icheng281.github.io/2024/05/07/%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91/</id>
    <published>2024-05-07T03:07:29.000Z</published>
    <updated>2024-05-07T03:09:47.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立四叉树"><a href="#建立四叉树" class="headerlink" title="建立四叉树"></a>建立四叉树</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p><p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><ul><li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>。注意，当 <code>isLeaf</code> 为 <strong>False</strong> 时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</li><li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public boolean val;</span><br><span class="line">    public boolean isLeaf;</span><br><span class="line">    public Node topLeft;</span><br><span class="line">    public Node topRight;</span><br><span class="line">    public Node bottomLeft;</span><br><span class="line">    public Node bottomRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以按以下步骤为二维区域构建四叉树：</p><ol><li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li><li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li><li>使用适当的子网格递归每个子节点。</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt="img"></p><p><strong>四叉树格式：</strong></p><p>你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p><p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[1,0]]</span><br><span class="line">输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]</span><br><span class="line">解释：此示例的解释如下：</span><br><span class="line">请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]</span><br><span class="line">输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]</span><br><span class="line">解释：网格中的所有值都不相同。我们将网格划分为四个子网格。</span><br><span class="line">topLeft，bottomLeft 和 bottomRight 均具有相同的值。</span><br><span class="line">topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。</span><br><span class="line">解释如下图所示：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2x</code> 其中 <code>0 &lt;= x &lt;= 6</code></li></ol><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>思路及算法</strong></p><p>具体地，我们用递归函数 dfs(r0,c0,r1,c1) 处理给定的矩阵 grid 行开始到 r1−1 行，从 c0 和 c1−1 列的部分。我们首先判定这一部分是否均为 0 或 1，如果是，那么这一部分对应的是一个叶节点，我们构造出对应的叶节点并结束递归；如果不是，那么这一部分对应的是一个非叶节点，我们需要将其分成四个部分：行的分界线为 $\dfrac{r_0+r_1}{2} $，列的分界线为 $\dfrac{c_0+c_1}{2} $，根据这两条分界线递归地调用 dfs 函数得到四个部分对应的树，再将它们对应地挂在非叶节点的四个子节点上。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node *construct(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        function&lt;Node*(int, int, int, int)&gt; dfs = [&amp;](int r0, int c0, int r1, int c1) &#123;</span><br><span class="line">            for (int i = r0; i &lt; r1; ++i) &#123;</span><br><span class="line">                for (int j = c0; j &lt; c1; ++j) &#123;</span><br><span class="line">                    if (grid[i][j] != grid[r0][c0]) &#123; // 不是叶节点</span><br><span class="line">                        return new Node(</span><br><span class="line">                                true,</span><br><span class="line">                                false,</span><br><span class="line">                                dfs(r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),</span><br><span class="line">                                dfs(r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),</span><br><span class="line">                                dfs((r0 + r1) / 2, c0, r1, (c0 + c1) / 2),</span><br><span class="line">                                dfs((r0 + r1) / 2, (c0 + c1) / 2, r1, c1)</span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 是叶节点</span><br><span class="line">            return new Node(grid[r0][c0], true);</span><br><span class="line">        &#125;;</span><br><span class="line">        return dfs(0, 0, grid.size(), grid.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node construct(int[][] grid) &#123;</span><br><span class="line">        return dfs(grid, 0, 0, grid.length, grid.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node dfs(int[][] grid, int r0, int c0, int r1, int c1) &#123;</span><br><span class="line">        boolean same = true;</span><br><span class="line">        for (int i = r0; i &lt; r1; ++i) &#123;</span><br><span class="line">            for (int j = c0; j &lt; c1; ++j) &#123;</span><br><span class="line">                if (grid[i][j] != grid[r0][c0]) &#123;</span><br><span class="line">                    same = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!same) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (same) &#123;</span><br><span class="line">            return new Node(grid[r0][c0] == 1, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node ret = new Node(</span><br><span class="line">            true,</span><br><span class="line">            false,</span><br><span class="line">            dfs(grid, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),</span><br><span class="line">            dfs(grid, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),</span><br><span class="line">            dfs(grid, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),</span><br><span class="line">            dfs(grid, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)</span><br><span class="line">        );</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n^2^log⁡n)。这里给出一个较为宽松的时间复杂度上界。记 T(n)T(n)T(n) 为边长为 nnn 的数组需要的时间复杂度，那么「判定这一部分是否均为 0 或 1」需要的时间为 O(n^2^)，在这之后会递归调用 4 规模为 n&#x2F;2 的子问题，那么有：</p><p>T(n)&#x3D;4T(n&#x2F;2)+O(n^2^)<br>以及：</p><p>T(1)&#x3D;O(1)<br>根据主定理，可以得到 T(n)&#x3D;O(n^2^log⁡n)。但如果判定需要的时间达到了渐近紧界 Θ(n^2^)，那么说明这一部分包含的元素大部分都是相同的，也就是说，有很大概率在深入递归时遇到元素完全相同的一部分，从而提前结束递归。因此 O(n^2^log⁡n) 的时间复杂度是很宽松的。</p></li><li><p>空间复杂度：O(log⁡n)，即为递归需要使用的栈空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建立四叉树&quot;&gt;&lt;a href=&quot;#建立四叉树&quot; class=&quot;headerlink&quot; title=&quot;建立四叉树&quot;&gt;&lt;/a&gt;建立四叉树&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的最小绝对差</title>
    <link href="https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <id>https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</id>
    <published>2024-05-07T02:16:46.000Z</published>
    <updated>2024-05-07T02:17:41.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><strong>思路及算法</strong></p><p>考虑对升序数组 a 求任意两个元素之差的绝对值的最小值，答案一定为相邻两个元素之差的最小值，即</p><p>ans&#x3D;min⁡i&#x3D;0n−2{a[i+1]−a[i]}<br>其中 n 为数组 a 的长度。其他任意间隔距离大于等于 2 的下标对 (i,j) 的元素之差一定大于下标对 (i,i+1) 的元素之差，故不需要再被考虑。</p><p>回到本题，本题要求二叉搜索树任意两节点差的绝对值的最小值，而我们知道二叉搜索树有个性质为二叉搜索树中序遍历得到的值序列是递增有序的，因此我们只要得到中序遍历后的值序列即能用上文提及的方法来解决。</p><p>朴素的方法是经过一次中序遍历将值保存在一个数组中再进行遍历求解，我们也可以在中序遍历的过程中用 pre 变量保存前驱节点的值，这样即能边遍历边更新答案，不再需要显式创建数组来保存，需要注意的是 pre 的初始值需要设置成任意负数标记开头，下文代码中设置为 −1。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int&amp; pre, int&amp; ans) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, pre, ans);</span><br><span class="line">        if (pre == -1) &#123;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = min(ans, root-&gt;val - pre);</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right, pre, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        int ans = INT_MAX, pre = -1;</span><br><span class="line">        dfs(root, pre, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int pre;</span><br><span class="line">    int ans;</span><br><span class="line"></span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -1;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        if (pre == -1) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 为二叉搜索树节点的个数。每个节点在中序遍历中都会被访问一次且只会被访问一次，因此总时间复杂度为 O(n)。</p></li><li><p>空间复杂度：O(n)。递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到 O(n) 级别。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;二叉搜索树的最小绝对差&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; cla</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的锯齿形层序遍历</title>
    <link href="https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2024-05-07T02:15:38.000Z</published>
    <updated>2024-05-07T02:18:19.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><strong>思路及算法</strong></p><p>为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。</p><p>双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：</p><ul><li><p>如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。</p></li><li><p>如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。</p></li></ul><p>当遍历结束的时候我们就得到了答案数组。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            deque&lt;int&gt; levelList;</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                auto node = nodeQueue.front();</span><br><span class="line">                nodeQueue.pop();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.push_back(node-&gt;val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.push_front(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(vector&lt;int&gt;&#123;levelList.begin(), levelList.end()&#125;);</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        boolean isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; levelList = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode curNode = nodeQueue.poll();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.offerLast(curNode.val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.offerFirst(curNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.left != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.right != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(new LinkedList&lt;Integer&gt;(levelList));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。</p></li><li><p>空间复杂度：O(N)。我们需要维护存储节点的队列和存储节点值的双端队列，空间复杂度为 O(N)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的锯齿形层序遍历&quot;&gt;&lt;a href=&quot;#二叉树的锯齿形层序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的锯齿形层序遍历&quot;&gt;&lt;/a&gt;二叉树的锯齿形层序遍历&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; cla</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层平均值</title>
    <link href="https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <id>https://icheng281.github.io/2024/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</id>
    <published>2024-05-07T02:14:14.000Z</published>
    <updated>2024-05-07T02:17:15.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数量在 <code>[1, 104]</code> 范围内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，counts 用于存储二叉树的每一层的节点数，sums 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 i 层，则将 counts[i] 的值加 1，并将该节点的值加到 sums[i]。遍历结束之后，第 i 层的平均值即为 sums[i]&#x2F;counts[i]。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; counts = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Double&gt; sums = new ArrayList&lt;Double&gt;();</span><br><span class="line">        dfs(root, 0, counts, sums);</span><br><span class="line">        List&lt;Double&gt; averages = new ArrayList&lt;Double&gt;();</span><br><span class="line">        int size = sums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            averages.add(sums.get(i) / counts.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return averages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode root, int level, List&lt;Integer&gt; counts, List&lt;Double&gt; sums) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (level &lt; sums.size()) &#123;</span><br><span class="line">            sums.set(level, sums.get(level) + root.val);</span><br><span class="line">            counts.set(level, counts.get(level) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sums.add(1.0 * root.val);</span><br><span class="line">            counts.add(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, level + 1, counts, sums);</span><br><span class="line">        dfs(root.right, level + 1, counts, sums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        auto counts = vector&lt;int&gt;();</span><br><span class="line">        auto sums = vector&lt;double&gt;();</span><br><span class="line">        dfs(root, 0, counts, sums);</span><br><span class="line">        auto averages = vector&lt;double&gt;();</span><br><span class="line">        int size = sums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            averages.push_back(sums[i] / counts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return averages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int level, vector&lt;int&gt; &amp;counts, vector&lt;double&gt; &amp;sums) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (level &lt; sums.size()) &#123;</span><br><span class="line">            sums[level] += root-&gt;val;</span><br><span class="line">            counts[level] += 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sums.push_back(1.0 * root-&gt;val);</span><br><span class="line">            counts.push_back(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, level + 1, counts, sums);</span><br><span class="line">        dfs(root-&gt;right, level + 1, counts, sums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong> </p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。<br>深度优先搜索需要对每个节点访问一次，对于每个节点，维护两个数组的时间复杂度都是 O(1)，因此深度优先搜索的时间复杂度是 O(n)。<br>遍历结束之后计算每层的平均值的时间复杂度是 O(h)，其中 h 是二叉树的高度，任何情况下都满足 h≤n。<br>因此总时间复杂度是 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度取决于两个数组的大小和递归调用的层数，两个数组的大小都等于二叉树的高度，递归调用的层数不会超过二叉树的高度，最坏情况下，二叉树的高度等于节点个数。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>也可以使用广度优先搜索计算二叉树的层平均值。从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p><p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p><ul><li><p>初始时，将根节点加入队列；</p></li><li><p>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</p></li></ul><p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p><p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 size，遍历时只遍历 size 个节点，即可满足每一轮遍历的是同一层的全部节点。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Double&gt; averages = new ArrayList&lt;Double&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                TreeNode left = node.left, right = node.right;</span><br><span class="line">                if (left != null) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (right != null) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            averages.add(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        return averages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        auto averages = vector&lt;double&gt;();</span><br><span class="line">        auto q = queue&lt;TreeNode*&gt;();</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                auto left = node-&gt;left, right = node-&gt;right;</span><br><span class="line">                if (left != nullptr) &#123;</span><br><span class="line">                    q.push(left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (right != nullptr) &#123;</span><br><span class="line">                    q.push(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            averages.push_back(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        return averages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。<br>广度优先搜索需要对每个节点访问一次，时间复杂度是 O(n)。<br>需要对二叉树的每一层计算平均值，时间复杂度是 O(h)，其中 h 是二叉树的高度，任何情况下都满足 h≤n。<br>因此总时间复杂度是 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度取决于队列开销，队列中的节点个数不会超过 n。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的层平均值&quot;&gt;&lt;a href=&quot;#二叉树的层平均值&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层平均值&quot;&gt;&lt;/a&gt;二叉树的层平均值&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>求根结点到叶节点数字之和</title>
    <link href="https://icheng281.github.io/2024/05/06/%E6%B1%82%E6%A0%B9%E7%BB%93%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>https://icheng281.github.io/2024/05/06/%E6%B1%82%E6%A0%B9%E7%BB%93%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2024-05-06T02:13:01.000Z</published>
    <updated>2024-05-06T02:22:57.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求根结点到叶节点数字之和"><a href="#求根结点到叶节点数字之和" class="headerlink" title="求根结点到叶节点数字之和"></a>求根结点到叶节点数字之和</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 = 12 + 13 = 25</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p><strong>思路及算法</strong></p><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</p><p><img src="https://assets.leetcode-cn.com/solution-static/129/fig1.png" alt="fig1"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(TreeNode* root, int prevSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = prevSum * 10 + root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        return dfs(root, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">        return dfs(root, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(TreeNode root, int prevSum) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = prevSum * 10 + root.val;</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>使用广度优先搜索，需要维护两个队列，分别存储节点和节点对应的数字。</p><p>初始时，将根节点和根节点的值分别加入两个队列。每次从两个队列分别取出一个节点和一个数字，进行如下操作：</p><ul><li><p>如果当前节点是叶子节点，则将该节点对应的数字加到数字之和；</p></li><li><p>如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。</p></li></ul><p>搜索结束后，即可得到所有叶子节点对应的数字之和。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; numQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        numQueue.push(root-&gt;val);</span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();</span><br><span class="line">            int num = numQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            numQueue.pop();</span><br><span class="line">            TreeNode* left = node-&gt;left;</span><br><span class="line">            TreeNode* right = node-&gt;right;</span><br><span class="line">            if (left == nullptr &amp;&amp; right == nullptr) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (left != nullptr) &#123;</span><br><span class="line">                    nodeQueue.push(left);</span><br><span class="line">                    numQueue.push(num * 10 + left-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (right != nullptr) &#123;</span><br><span class="line">                    nodeQueue.push(right);</span><br><span class="line">                    numQueue.push(num * 10 + right-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; numQueue = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        numQueue.offer(root.val);</span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.poll();</span><br><span class="line">            int num = numQueue.poll();</span><br><span class="line">            TreeNode left = node.left, right = node.right;</span><br><span class="line">            if (left == null &amp;&amp; right == null) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (left != null) &#123;</span><br><span class="line">                    nodeQueue.offer(left);</span><br><span class="line">                    numQueue.offer(num * 10 + left.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (right != null) &#123;</span><br><span class="line">                    nodeQueue.offer(right);</span><br><span class="line">                    numQueue.offer(num * 10 + right.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于队列，每个队列中的元素个数不会超过 n 。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求根结点到叶节点数字之和&quot;&gt;&lt;a href=&quot;#求根结点到叶节点数字之和&quot; class=&quot;headerlink&quot; title=&quot;求根结点到叶节点数字之和&quot;&gt;&lt;/a&gt;求根结点到叶节点数字之和&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot;</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>填充每个结点的下一个右侧指针II</title>
    <link href="https://icheng281.github.io/2024/05/06/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88II/"/>
    <id>https://icheng281.github.io/2024/05/06/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88II/</id>
    <published>2024-05-06T02:11:47.000Z</published>
    <updated>2024-05-06T02:23:32.410Z</updated>
    
    <content type="html"><![CDATA[<p> 填充每个结点的下一个右侧指针II</p><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 6000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）层次遍历"><a href="#（1）层次遍历" class="headerlink" title="（1）层次遍历"></a>（1）层次遍历</h3><p><strong>思路及算法</strong></p><p>这道题希望我们把二叉树各个层的点组织成链表，一个非常直观的思路是层次遍历。树的层次遍历基于广度优先搜索，它按照层的顺序遍历二叉树，在遍历第 iii 层前，一定会遍历完第 i−1 层。</p><p>算法如下：初始化一个队列 q，将根结点放入队列中。当队列不为空的时候，记录当前队列大小为 n，从队列中以此取出 n 个元素并通过这 n 个元素拓展新节点。如此循环，直到队列为空。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            Node *last = nullptr;</span><br><span class="line">            for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">                Node *f = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if (f-&gt;left) &#123;</span><br><span class="line">                    q.push(f-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (f-&gt;right) &#123;</span><br><span class="line">                    q.push(f-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                if (i != 1) &#123;</span><br><span class="line">                    last-&gt;next = f;</span><br><span class="line">                &#125;</span><br><span class="line">                last = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = new ArrayDeque&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int n = queue.size();</span><br><span class="line">            Node last = null;</span><br><span class="line">            for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">                Node f = queue.poll();</span><br><span class="line">                if (f.left != null) &#123;</span><br><span class="line">                    queue.offer(f.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (f.right != null) &#123;</span><br><span class="line">                    queue.offer(f.right);</span><br><span class="line">                &#125;</span><br><span class="line">                if (i != 1) &#123;</span><br><span class="line">                    last.next = f;</span><br><span class="line">                &#125;</span><br><span class="line">                last = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>记树上的点的个数为 N。</p><ul><li><p>时间复杂度：O(N)。我们需要遍历这棵树上所有的点，时间复杂度为 O(N)。</p></li><li><p>空间复杂度：O(N)。即队列的空间代价。</p></li></ul><h3 id="（2）指针"><a href="#（2）指针" class="headerlink" title="（2）指针"></a>（2）指针</h3><p><strong>思路及算法</strong></p><p>因为必须处理树上的所有节点，所以无法降低时间复杂度，但是可以尝试降低空间复杂度。</p><p>在方法一中，因为对树的结构一无所知，所以使用队列保证有序访问同一层的所有节点，并建立它们之间的连接。然而不难发现：一旦在某层的节点之间建立了 next 指针，那这层节点实际上形成了一个链表。因此，如果先去建立某一层的 next 指针，再去遍历这一层，就无需再使用队列了。</p><p>基于该想法，提出降低空间复杂度的思路：如果第 iii 层节点之间已经建立 next 指针，就可以通过 next 指针访问该层的所有节点，同时对于每个第 i 层的节点，我们又可以通过它的 left 和 right 指针知道其第 i+1 层的孩子节点是什么，所以遍历过程中就能够按顺序为第 i+1 层节点建立 next 指针。</p><p>具体来说：</p><ul><li>从根节点开始。因为第 0 层只有一个节点，不需要处理。可以在上一层为下一层建立 next 指针。该方法最重要的一点是：位于第 x 层时为第 x+1 层建立 next 指针。一旦完成这些连接操作，移至第 x+1 层为第 x+2 层建立 next 指针。</li><li>当遍历到某层节点时，该层节点的 next 指针已经建立。这样就不需要队列从而节省空间。每次只要知道下一层的最左边的节点，就可以从该节点开始，像遍历链表一样遍历该层的所有节点。</li></ul><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void handle(Node* &amp;last, Node* &amp;p, Node* &amp;nextStart) &#123;</span><br><span class="line">        if (last) &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">        &#125; </span><br><span class="line">        if (!nextStart) &#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *start = root;</span><br><span class="line">        while (start) &#123;</span><br><span class="line">            Node *last = nullptr, *nextStart = nullptr;</span><br><span class="line">            for (Node *p = start; p != nullptr; p = p-&gt;next) &#123;</span><br><span class="line">                if (p-&gt;left) &#123;</span><br><span class="line">                    handle(last, p-&gt;left, nextStart);</span><br><span class="line">                &#125;</span><br><span class="line">                if (p-&gt;right) &#123;</span><br><span class="line">                    handle(last, p-&gt;right, nextStart);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    Node last = null, nextStart = null;</span><br><span class="line"></span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        while (start != null) &#123;</span><br><span class="line">            last = null;</span><br><span class="line">            nextStart = null;</span><br><span class="line">            for (Node p = start; p != null; p = p.next) &#123;</span><br><span class="line">                if (p.left != null) &#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (p.right != null) &#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handle(Node p) &#123;</span><br><span class="line">        if (last != null) &#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125; </span><br><span class="line">        if (nextStart == null) &#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>记树上的点的个数为 N。</p><ul><li><p>时间复杂度：O(N)。我们需要遍历这棵树上所有的点，时间复杂度为 O(N)。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 填充每个结点的下一个右侧指针II&lt;/p&gt;
&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; title=&quot;1.题目内容&quot;&gt;&lt;/a&gt;1.题目内容&lt;/h2&gt;&lt;p&gt;给定一个二叉树：&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树迭代器</title>
    <link href="https://icheng281.github.io/2024/05/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://icheng281.github.io/2024/05/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2024-05-06T02:10:50.000Z</published>
    <updated>2024-05-06T02:22:20.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器"></a>二叉搜索树迭代器</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><ul><li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li><li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li><li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li></ul><p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p><p><strong>示例：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, 3, 7, true, 9, true, 15, true, 20, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);</span><br><span class="line">bSTIterator.next();    // 返回 3</span><br><span class="line">bSTIterator.next();    // 返回 7</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 9</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 15</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 20</span><br><span class="line">bSTIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 106</code></li><li>最多调用 <code>105</code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><strong>思路及算法</strong></p><p>通过迭代的方式对二叉树做中序遍历。此时，我们无需预先计算出中序遍历的全部结果，只需要实时维护当前栈的情况即可。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode* cur;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode* root): cur(root) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    int next() &#123;</span><br><span class="line">        while (cur != nullptr) &#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        int ret = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        return cur != nullptr || !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">    private TreeNode cur;</span><br><span class="line">    private Deque&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    public BSTIterator(TreeNode root) &#123;</span><br><span class="line">        cur = root;</span><br><span class="line">        stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int next() &#123;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        int ret = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cur != null || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：显然，初始化和调用 hasNext()都只需要 O(1) 的时间。每次调用 next() 函数最坏情况下需要 O(n)的时间；但考虑到 n 次调用 next() 函数总共会遍历全部的 n 个节点，因此总的时间复杂度为 O(n)，因此单次调用平均下来的均摊复杂度为 O(1)。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树的节点数量。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树迭代器&quot;&gt;&lt;a href=&quot;#二叉搜索树迭代器&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树迭代器&quot;&gt;&lt;/a&gt;二叉搜索树迭代器&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的右视图</title>
    <link href="https://icheng281.github.io/2024/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://icheng281.github.io/2024/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2024-04-29T01:53:36.000Z</published>
    <updated>2024-04-29T02:00:54.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）深度优先搜索"><a href="#（1）深度优先搜索" class="headerlink" title="（1）深度优先搜索"></a>（1）深度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。</p><p><img src="https://assets.leetcode-cn.com/solution-static/199/fig1.png" alt="fig1"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; depthStack = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            int depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        stack&lt;int&gt; depthStack;</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeStack.top();nodeStack.pop();</span><br><span class="line">            int depth = depthStack.top();depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) &#123;</span><br><span class="line">                    rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node -&gt; left);</span><br><span class="line">                nodeStack.push(node -&gt; right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p></li><li><p>空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p></li></ul><h3 id="（2）广度优先搜索"><a href="#（2）广度优先搜索" class="headerlink" title="（2）广度优先搜索"></a>（2）广度优先搜索</h3><p><strong>思路及算法</strong></p><p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。除了将栈改成队列，并去除了 rightmost_value_at_depth 之前的检查外，算法没有别的改动。</p><p><img src="https://assets.leetcode-cn.com/solution-static/199/fig2.png" alt="fig2"></p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        depthQueue.add(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.remove();</span><br><span class="line">            int depth = depthQueue.remove();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line"></span><br><span class="line">                nodeQueue.add(node.left);</span><br><span class="line">                nodeQueue.add(node.right);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();nodeQueue.pop();</span><br><span class="line">            int depth = depthQueue.front();depthQueue.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">                nodeQueue.push(node -&gt; left);</span><br><span class="line">                nodeQueue.push(node -&gt; right);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p></li><li><p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的右视图&quot;&gt;&lt;a href=&quot;#二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;二叉树的右视图&quot;&gt;&lt;/a&gt;二叉树的右视图&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="https://icheng281.github.io/2024/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://icheng281.github.io/2024/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2024-04-29T01:52:58.000Z</published>
    <updated>2024-04-29T02:00:32.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树<strong>先序遍历</strong>顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="（1）前序遍历"><a href="#（1）前序遍历" class="headerlink" title="（1）前序遍历"></a>（1）前序遍历</h3><p><strong>思路及算法</strong></p><p>将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        int size = list.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev = list.get(i - 1), curr = list.get(i);</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preorderTraversal(TreeNode root, List&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; l;</span><br><span class="line">        preorderTraversal(root, l);</span><br><span class="line">        int n = l.size();</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode *prev = l.at(i - 1), *curr = l.at(i);</span><br><span class="line">            prev-&gt;left = nullptr;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;</span><br><span class="line">        if (root != NULL) &#123;</span><br><span class="line">            l.push_back(root);</span><br><span class="line">            preorderTraversal(root-&gt;left, l);</span><br><span class="line">            preorderTraversal(root-&gt;right, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历之后，需要对每个节点更新左右子节点的信息，时间复杂度也是 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈（递归调用栈或者迭代中显性使用的栈）和存储前序遍历结果的列表的大小，栈内的元素个数不会超过 n，前序遍历列表中的元素个数是 n。</p></li></ul><h3 id="（2）前序遍历和展开同步进行"><a href="#（2）前序遍历和展开同步进行" class="headerlink" title="（2）前序遍历和展开同步进行"></a>（2）前序遍历和展开同步进行</h3><p><strong>思路及算法</strong></p><p>由于将节点展开之后会破坏二叉树的结构而丢失子节点的信息，因此前序遍历和展开为单链表分成了两步。能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？</p><p>之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。只要对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失，就可以将前序遍历和展开为单链表同时进行。</p><p>该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。</p><p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = null;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode curr = stack.pop();</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.left = null;</span><br><span class="line">                prev.right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode left = curr.left, right = curr.right;</span><br><span class="line">            if (right != null) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != null) &#123;</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        auto stk = stack&lt;TreeNode*&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        while (!stk.empty()) &#123;</span><br><span class="line">            TreeNode *curr = stk.top(); stk.pop();</span><br><span class="line">            if (prev != nullptr) &#123;</span><br><span class="line">                prev-&gt;left = nullptr;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">            if (right != nullptr) &#123;</span><br><span class="line">                stk.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != nullptr) &#123;</span><br><span class="line">                stk.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历的同时对每个节点更新左右子节点的信息，更新子节点信息的时间复杂度是 O(1)，因此总时间复杂度是 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈的大小，栈内的元素个数不会超过 n。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树展开为链表&quot;&gt;&lt;a href=&quot;#二叉树展开为链表&quot; class=&quot;headerlink&quot; title=&quot;二叉树展开为链表&quot;&gt;&lt;/a&gt;二叉树展开为链表&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="https://icheng281.github.io/2024/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://icheng281.github.io/2024/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2024-04-28T03:03:10.000Z</published>
    <updated>2024-04-28T03:06:02.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><h2 id="1-题目内容"><a href="#1-题目内容" class="headerlink" title="1.题目内容"></a>1.题目内容</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>思路及算法</strong></p><p>祖先的定义： 若节点 p 在节点 root 的左（右）子树中，或 p&#x3D;root ，则称 root 是 p 的祖先。</p><p>最近公共祖先的定义： 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p><img src="https://pic.leetcode-cn.com/1599885247-rxcHcZ-Picture1.png" alt="Picture1.png"></p><p>根据以上定义，若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ol><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p&#x3D;root ，且 q 在 root 的左或右子树中；</li><li>q&#x3D;root ，且 p 在 root 的左或右子树中；</li></ol><p><img src="https://pic.leetcode-cn.com/1599885247-mgYjRv-Picture2.png" alt="Picture2.png"></p><p>考虑通过递归对二叉树进行先序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null || root == p || root == q) return root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left == null) return right;</span><br><span class="line">        if(right == null) return left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(root == nullptr || root == p || root == q) return root;</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        if(left == nullptr) return right;</span><br><span class="line">        if(right == nullptr) return left;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(N)： 其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉树的最近公共祖先&lt;/h1&gt;&lt;h2 id=&quot;1-题目内容&quot;&gt;&lt;a href=&quot;#1-题目内容&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="学习" scheme="https://icheng281.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
